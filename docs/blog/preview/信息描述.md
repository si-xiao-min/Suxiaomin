# 组织形式

## 考题

总共是四个题型，一个是单项选择题，单项选择题总共有十个题。这十个题呢，基本上我看了一下之前给大家出的题，我个人觉得还是比较简单的。然后还有名词解释，我们以往的名词解释总共是二十分，但是这次我把这个分值扩大一点，让大家尽量能够多拿一点分，名词解释六个小题，每个小题五分，总共三十分。然后呢，还有一个资源描述题，等会儿我跟大家讲。要根据我们第七章当中相关的内容，大家等会儿可以在现场查看相关的课程 PPT，特别是当中的一些实际例子，待会大家在试卷上要把一些相关的代码写出来。但是呢，像一些我们之前上课给大家讲过的那些所谓名词，这些我上课跟大家讲过的不用背的东西，基本都不用背。

## 建议

自己去问AI，让AI出一些资源描述题，自己手写一下，光看，是学不会的。

我自己血的教学。

注意，怎么写scheme，怎么使用编码体系修饰词，怎么使用元素修饰符。

老师确实已经把题目都透露得差不多了，那么就好好背诵吧。

## 组织

整体按照章节进行划分，

1. 第一章：绪论
2. 二三四章：古典信息描述
3. 五六七章：现代信息描述
4. 信息描述的发展
5. 资源描述题

每一章的开头的内容均为老师对于考点的描述，可以作为参考。

前面的部分让 AI 使用图标可视化呈现，方便背诵。

剩下的内容的参考

1. 教材
2. PPT
3. AI

私货和考试无关，备考的时候可以忽视。

[toc]

# 第一章：绪论

我现在大概把这个重点跟大家讲一下，首先大家可以看一下第一章，第一章像前面这个信息表述基本的内容，我们就不做过多介绍，不做过多考察了，大家都很清楚对吧，包括我们之前学的信息管理基础、信息系统其实都给大家考察过，那么在这里呢，三十一页，这里就是对网络信息描述，我们就一直说，现在需要重点掌握的是对网络信息的描述，那网络信息描述这里的和几个几大核心的方法，大家最起码要知道这个方法，还有包括我们在这个资源描述框架 Rds，它的一些基本概念，包括它的规则是什么，大家要有所了解。然后还有就是关联数据，第一个东西是关联数据，我们之前一直跟大家讲关联数据，大家要注意，比方说我们之前一直在讲这个关联数据，它和语义网的关系，以及原数据和语义网的关系，我们知道大家要把这个关系搞清楚，就是这个关联数据还有原数据，它们和语义网实现之间的一个关系，大家要搞清楚。

## 🎯 信息描述的目的

1. 🛤️ **途径**：对信息资源进行有效排序  
2. 📚 **结果**：形成文献目录 / 信息资源库  
3. ⚙️ **作用**：  

   1. 🧾 解释信息资源（🌐 网络 / 🏛️ 实体）的  
      1. 🖼️ 外在特征（如题名、作者、载体）  
      2. 🧠 内在特征（如主题、内容结构）  
     2. 🔍 为用户提供信息检索通道  

### ❓ 追问：信息描述 ↔ 信息组织 ↔ 信息检索 ↔ 目录学？

1. 📜 → 🌐：信息描述 = 网络时代对 **目录学** & **文献编目** 的继承 + 发展  
2. 🧩：信息描述 ⊂ 信息组织，🎯 服务于信息检索  
3. 🗂️ **信息组织（广义）包含**：  
   1. ✅ 信息选择  
   2. 🔍 信息分析  
   3. 📝 信息描述  
   4. 💾 信息存储  


---

## 🌐 网络信息描述（第一章重点）

### 🏷️ 元数据（Metadata）

- 📦 “关于数据的数据”  
- 🏗️ 数据仓库建设中产生的关键数据：  
  1. 📌 数据定义  
  2. 🎯 目标定义  
  3. ⚙️ 转换规则  

- 🌍 **DC 元数据** = 通用元数据标准（Dublin Core）

### 🏗️ 置标语言（Markup Language）

- 🗣️ 人工语言，融合文本 + 元信息  
- 📄 展现文档结构 & 数据处理细节  
- 📌 例：  
  - `HTML` → 🖥️ 网页展示  
  - `XML` → 🧩 结构化数据交换  


### 🔗 结合策略

| 维度       | 工具       | 目的           |
| ---------- | ---------- | -------------- |
| 🧱 结构分解 | 🏷️ 元数据   | 描述资源“骨架” |
| 🧠 语义分解 | 🏗️ 置标语言 | 表达资源“含义” |

### 💎 价值（5 大核心）

1. 🗣️ 提升知识表述能力  
2. 🔎 挖掘内部内容  
3. 🌱 孕育新型资源  
4. 🔄 支持系统互操作  
5. 🔐 实现数字鉴别（Digital Identification）

---

## 🧠 RDF（资源描述框架）概要

### 📌 核心概念

1. 📦 **RDF** = Resource Description Framework  
2. 🌐 专为描述 Web 资源而设计  
3. 🧩 提供：  
  - 📐 数据模型（基于 E-R 模型）  
  - 📜 语法规范  
4. 🧾 三元组结构：**主语 – 谓语 – 宾语**  
  - 🎯 资源（Subject）  
  - 🔗 属性（Predicate）  
  - 📌 值（Object）  
5. 🔗 支持构建 **关联数据**（Linked Data）  
6. 🤖 可被计算机自动读取 & 理解  

### 📄 RDF/XML

- 🧱 RDF = 逻辑/语义框架  
- 📜 RDF/XML = 其一种 **语法实现**（基于 XML）  
- 🐢 类似实现：**RDF/Turtle**（更简洁，专为语义网优化）  
> ⏳ 注：教材较早，未涵盖 JSON-LD 等现代格式

### 📏 RDF 规则

- 每个陈述 = 1 个三元组  
- 结构：**主题 → 谓语 → 客体**

### 📚 RDFS（RDF Schema）

- 📖 = RDF 的 **词汇描述语言**（定义类、属性等）  
- ⚠️ 区别于 **scheme**（编码体系，如日期格式 `YYYY-MM-DD`）

---

## 🔗 关联数据（Linked Data）概要

> 📌 参见：[信息描述的发展](#信息描述的发展)

### 🛤️ 途径

1. 🌍 构建 **“存在”的机器可读映射**  
   1. 🧍 物质世界事物  
   2. 💭 精神世界概念  

2. 🕸️ 形成语义网络（Semantic Web）

### 🎯 追求

- 📈 最大化信息利用率

### 📊 现状

1. 🧩 语义网络的 **简化实现**  
2. 🏛️ 主要服务对象：  
  - 图书馆  
  - 档案馆  
  - 博物馆  
  - 知识机构  
  → ❌ 非直接面向普通用户  

### 🌱 实践趋势

1. 🔁 **深化 + 广化**  
2. 🌐 **多中心化**：  
  3. 🕰️ 早期：以 Wikipedia 为中心  
  4. 🔄 当前：去中心化，多元节点并存  
5. 📚 **图书馆应积极参与** 关联数据建设（参见 P.33）

# 第二章：MARC 📚

第二章我们主要看 CNMARK。CNMARK 里面呢，我们要大家知道，我们之前一直跟大家讲，不需要大家背这些很传统的这些内容。但是呢，大家最起码要知道 CNMARK 里边从零到九每个代码它所代表的含义，以及它代表含义的具体内涵，也就是每个代码它的具体内涵。你比方说，哪些信息要放在哪一块儿当中，哪些信息放在哪些功能块当中，大家一定要掌握。

好，然后七十五页是 MARK21，七十五页 MARK21 这里，大家要掌握的是要知道 MARK21 这几个字段，每个字段比方说我现在问你，同边说明字段应该是几开头的字段对吧？那大家要清楚它的这样的一个对应关系。好，这是我们那个第二章的内容，

🧠 **掌握大概即可，无需深入具体字段细节。**

本章聚焦于 **CNMARC**：

- ❗ 不要求死记硬背传统内容  
- ✅ 但需掌握 **0–9 功能块编号** 及其 **内涵**
- 🧩 理解 **信息应归属哪个功能块**
- 🔍 例如：题名信息 → 哪个块？责任说明 → 哪个块？

📖 **P75：MARC21**  
- 🎯 掌握字段开头数字与信息类型的对应关系  
  - 例：附注字段 → 以 **5** 开头（MARC21）  
- 🔁 对比 CNMARC 与 MARC21 的异同

---

## 基本概念 💡

- **MARC** = **Machine-Readable Cataloging** 🤖📄  
- 📦 **载体**：计算机存储 💾  
- ⚙️ **过程**：识别 → 处理 → 编辑 → 输出 🔄  
- 🌐 **MARC21** = USMARC + CANMARC + UKMARC → **通用、开放、网络时代格式** 🌍  
- 🇨🇳 **CNMARC** = 中国本土化 MARC 🏮

---

## 结构 🧱

遵循 **ISO 2709** 标准 📏

包含：

### 📌 头标区  
- 🔢 定长 24 字节  
- 🧠 “元数据的元数据”

### 📚 目次区  
- 🔍 数据字段区的索引  
- 🤖 自动生成  
- 📍 每条目含：标识符 ｜ 长度 ｜ 起始位置

### 📄 数据字段区  
- 🧾 主要内容所在  
  - **控制字段（00X）**  
    - 📏 除 `003` 外，均为定长  
  - **可变长数据字段**  
    - 🔧 含 字段标识符 & **字段指示符** & 子字段标识符 作为标识系统
    - 字段标识符
      - 识别字段的三个数字或者字符代码
      - 第一位用来区分代码块
    - 🔤 字段指示符：  
      - 👁️ 前两字符
      - 决定语义  
      - 🔢 为数字或空格  
    - ➕ 可含 **单/多个子字段**  
      - 📏 长度可变
    - 子字段标识符
      - 用来标记子字段的符号，是子字段开头的两个字符

如，<span style="color:#00FFFF;">490</span> <span style="color:#33FF33;">0#</span> <span style="color:#FFFF66;">$a</span> <span style="color:#CC00CC;">LIM</span>

1. <span style="color:#00FFFF;">490 </span>为字段标识符
2. <span style="color:#33FF33;">0# </span>为字段指示符
3. <span style="color:#FFFF66;">$a</span> 为子字段标识符
4. <span style="color:#CC00CC;">LIM</span> 为具体内容

### ➗ 分隔符  

- 🤖 自动生成  
- 符号：▲（字段开始）｜▼（字段结束）｜↔（记录结束）  
- 👁️ 提升可读性

---

## CNMARC 🇨🇳

- 📜 MARC 的中国规范版本  
- 📘 与第四章《图书的描述》联动  
- 🧱 头标区 & 目次区 ≈ 国际标准  
- 🎯 **数据字段为学习重点**

### 数据字段 🗂️

1. **功能块**  
   2. 🧮 字段首数字 **0–9** → 功能分块（类比杜威十进分类法）  
3. **字段**  
   4. 🔢 三位数，首位 = 功能块编号  
   5. 📏 可变长字段含 **字段指示符**（多数未定义）  
6. **子字段 / 数据元素**  
   7. ✅ 可选  
   8. 🔁 可重复 / ❌ 不可重复  
9. 🧠 子字段需结合 **数据元素** 才具完整语义

### 功能块 📦（参见 P45）

0. —— 🆔 **标识块**  
   1. 📑 记录控制号  
   2. 📰 ISSN（国际标准刊号）  
   3. 🔖 其他标识号（ISBN、ISRC 等）

1. —— 🔐 **编码信息块**  
   1. 🏷️ 记录性质  
   2. 🎛️ 特征编码（如语言、文献类型）

2. —— 📝 **著录信息块**（书目主体）  
   1. 📌 题名  
   2. 👤 责任说明  
   3. 🔄 版本说明  
   4. 📦 载体形态

3. —— 💬 **附注信息块**

4. —— 🔗 **款目连接块**  
   1. ↔ 类似 DC 的 **Relation**  
   2. 🌐 用于建立资源间关联

5. —— 📖 **相关题名块**

6. —— 🏷️ **主题分析块**  
   1. 📚 分类号（如中图法）  
   2. 🔍 主题词

7. —— 👥 **知识责任块**  
   1. 🧑‍🏫 负有知识责任者  
   2. 👥 个人 / 团体  
   3. ✅ 规范名称（权威控制）

8. —— 🌍 **国际使用块**

9. —— 🏠 **国内使用块**

---

## MARC21 🌐

### 功能块对比（参见 P76）📊

| 特点           | 说明                            |
| -------------- | ------------------------------- |
| ✅ **00X**      | 控制字段功能更丰富              |
| ✅ **2XX**      | 二者均为著录主体                |
| 🔄 **附注字段** | CNMARC: `3XX` ｜MARC21: `5XX`    |
| 🔗 **4XX**      | 从编说明 / 款目连接（语义相近） |

### 字段范围速查表 🗺️

| 字段范围    | 说明                     |
| ----------- | :----------------------- |
| **00X**     | ⚙️ 控制字段（记录元数据） |
| 01X~09X     | 🔢 各类号码与代码         |
| 1XX         | 👤 主要款目（责任者）     |
| **20X~24X** | 📌 题名字段               |
| **25X~28X** | 🔄 版本 & 出版信息        |
| **3XX**     | 📦 载体形态               |
| **4XX**     | 🔗 从编说明 / 连接        |
| **5XX**     | 💬 附注（MARC21）         |
| 6XX         | 🏷️ 主题检索               |
| 7XX         | 👥 款目（附加责任者）     |
| 80X~83X     | 📚 从编款目               |
| 841~88X     | 📍 馆藏 & 电子资源定位    |
| 9XX         | 🏠 本地预留字段           |

> 🔴 标红为教材上详细提到的内容，不代表考点

---

## 💭 思考题 & 论述题

### 🔍 思考题
1. 🤔 为什么 MARC 使用 **功能块编号（0–9）** 来组织数据字段？这种设计有何优势？
2. 🔄 CNMARC 与 MARC21 在 **附注字段** 的位置上有何不同？这反映了什么差异？
3. 🧩 子字段为何需要结合“数据元素”才能表达完整语义？请举例说明。
4. 📏 为什么 **头标区** 是“元数据的元数据”？它在记录处理中起什么作用？

### 📝 论述题
1. 🌍 试比较 **CNMARC** 与 **MARC21** 的功能块结构，分析其异同背后的文化、技术或应用需求差异。
2. 🧠 有人认为“MARC 已过时，应被 BIBFRAME 或 Schema.org 取代”。你是否同意？请结合 MARC 的结构特点与当前图书馆数据生态进行论述。
3. 📚 从 **信息组织** 角度，论述 CNMARC 中“功能块”划分如何支持高效检索与资源共享。



# 第三章：FRBR & RDA 📚

第三章，我们重点考虑的就是 FRBR 和 RDA，我们看一下在 3.1.5 的九十一页。3.1.5 的九十一页，大家首先要了解 FRBR 的一个基本概念，要知道 FRBR 在我们图书馆检索系统当中是怎么去应用的，这个大家要清楚。资源描述检索框架的 RDA，我们看一下九十九页这里，大家首先要对 RDA 的基本，比方说 RDA 它的依据是什么对吧，还有 RDA 它和其他的编目框架标准的特点是什么。至于像 RDA 的组织结构、它的这些内容，我们是不需要去掌握的因为在实践的过程当中，我们都知道，像在信息编目的组织编目的过程当中，使用一些文件编目规则的时候都有现成的工具可以参考。那么这里呢，我们只需要了解一下 RDA 的基本的目标、特点、任务，然后就是在一百一十九页的。

第三章重点：**FRBR** 与 **RDA**  
📍P91（3.1.5）→ 掌握 FRBR 基本概念 & 在检索系统中的应用  
📍P99 → 了解 RDA 的依据、特点，**无需掌握组织结构细节**（实践中有工具支持）  
📍P119 → 了解 RDA 的目标、任务、特点即可  

---

## FRBR 🧠

### 概念 💡  
- **F** unctional **R** equirements for **B** ibliographic **R** ecords  
- 📘 书目记录的功能需求  
- 🏗️ 建立 **书目数据模型**  
- 🔗 表示 **实体 ｜ 属性 ｜ 关系**  
- 🔄 基于 **“实体-关系”模型**（E-R Model）

```mermaid
flowchart LR
id1[实体1] <--关系--> id2[实体2]
```

### 实体 👥  
编目对象 = 实体  

三种类型：

1. 🎨 **创作的产品**  
   1. 🖋️ **作品（Work）**  
   2. 🎵 **内容表达（Expression）**（文字/音乐/图像等）  
   3. 📦 **载体表现（Manifestation）**（内容表达的物理/数字实现）  
   4. 📄 **单件（Item）**（具体复本，工业化产物）

2. 👤 **负责的个体和团体**  
3. 🏷️ **创作的主题**

### 属性 🔍  
- 🧭 所有检索途径 = 属性  
- 🔤 属性本质 = **字符串**（无自身属性，仅用于检索）  
- 🔗 关系可转化为属性，也可直接构建网络  

两类属性：

1. 🧬 **实体内在固有属性**  
   1. 📌 题名  
   2. 🏢 出版者名称（⚠️ 是字符串，非对象）

2. 🏷️ **外部分配属性**  
   1. 📚 分类号  
   2. 🔑 主题词

### 关系 🔗  
三种关系：

1. 📖 **书目实体关系**  
   1. 仅限 **Group 1 实体之间**（作品 ↔ 表达 ↔ 载体 ↔ 单件）

2. 👥 **责任关系**  
   1. 连接 **Group 1 ↔ Group 2**（如作者 ↔ 作品）

3. 🏷️ **主题关系**  
   1. 连接 **Group 1 ↔ Group 3**（如作品 ↔ 主题概念）

![FRBR 模型图](https://suxiaomin-tuil.oss-cn-wuhan-lr.aliyuncs.com/typora/20260104114608327.png)

### 作用 ⚙️  

1. 📚 **理论性**  
   1. 🚀 突破传统编目  
   2. 🔗 关联实体  
   3. 🧠 注重内容与创作过程  
   4. 🌱 体现文献本质  

2. 🛠️ **应用性**  
   1. 🌲 书目结构立体化 → 树形逻辑关系  
   2. 🧩 支持非书资源整合与标引  
   3. 👁️ 改善显示 & 提升检索体验  
   4. ⚡ 简化流程、降本增效  

### 应用 🌍  

IFLA 倡导落地：

- 🇦🇺 澳大利亚国家图书馆 → **AustLit**  
- 🌐 OCLC → **FictionFinder**  
- 🌐 OCLC → **FirstSearch**  
- 🇨🇳 中国国家图书馆 → 按著者聚合作品，关联单件  

实际效果：

1. 🔍 **基于属性字段检索**  
   1. 🏷️ 主题项  
   2. 👤 作者项  

2. 🔗 **基于实体关联建立作品联系**  
   1. 📚 同一作品的不同版本  
   2. 🌐 同一作品的不同语种  
   3. 🧠 同一主题下不同作者的作品  
   4. 📦 可呈现详细 **载体表现** 信息  

🎯 **支撑元数据标准 & 关联数据词表构建**

---

## RDA 🛠️

### 概念 💡  
- **R** esource **D** escription and **A** ccess（注意：**Access** ≠ Retrieval）  

1. 🌐 适应 **数字环境** 下资源描述与检索  
2. 🔄 继承并发展 **MARC & AACR2**
3. 📜 书目著录的 **规范与原则**  
4. 🧱 为 **支持 FRBR** 而设计  
5. 🧩 提供 **灵活框架**，兼容数据库 & OPAC  
6. 🧭 **独立于编码格式**（可用 MARC、RDF、BIBFRAME 等实现）

### 特点 ✨  
- 🧘 **灵活性 & 可控性**  
- 🧪 供其他领域开发标准的 **参照模板**  
- 🧠 基于 **FRBR & FRAD**

### 任务 🎯  
提供框架，支持用户完成四大任务：  
1. 🔍 **查找（Find）**  
2. 🔎 **识别（Identify）**  
3. ✅ **选择（Select）**  
4. 📥 **获取（Obtain）**

### 规范控制功能 📏  
- 📖 原则性指导  
- 🧱 解释结构  
- 📝 解释内容

### 组织结构 🗂️  
围绕 **FRBR & FRAD** 任务组织，助用户 **识别 & 关联** 资源：  

1. 📑 目次表  
2. ℹ️ 一般说明  
3. 📐 具体规则  
   1. 👥 实体及其属性  
   2. 🔗 关系  
4. 📎 附录  
5. 📖 术语表  
6. 🔍 索引

> 📌 RDA 细节 → **无需掌握**

### 关系 🔗  

#### 理论 🧠  
1. 🔍 **识别属性** → 揭示 **实体内在关系**  
2. 🔗 **关联实体** → 揭示 **实体外在关系**

#### 组成 🧱  
1. 🎯 被关联的实体  
2. 🏷️ 关联类型

---

## 扩展 ➕  

🔗 可跳转 [下一章](#第四章：图书的描述)  
❓ 若不理解以下问题，建议回顾：

> 🤔 请详细介绍 **FRBR & FRAD & RDA** 之间的关系与区别

教材总结：

✅ **相同点**  
1. 🎯 目的相同  
2. 🧭 用户任务相同  

🔄 **不同点**  
1. 📈 RDA **发展** 了 FRBR 的设计理念  
2. 📝 RDA **依据 FRBR 更新术语**

📌 总结：**继承 + 超越**



FRAR、FRBR 和 RDA 是图书馆学与信息组织领域中三个密切相关但又各有侧重的概念。它们共同构成了现代编目（cataloging）和书目控制（bibliographic control）的理论与实践基础。下面将分别介绍这三个概念，并详细说明它们之间的关系与区别。

---

### 一、基本定义

#### 1. FRBR（Functional Requirements for Bibliographic Records）

- **中文名称**：书目记录的功能需求
- **提出时间**：1998 年，由国际图联（IFLA）发布
- **目的**：重新思考传统编目模型，从用户需求出发，构建一个以“实体-关系”为核心的书目数据模型。
- **核心思想**：
  - 将书目对象划分为四个抽象层次（Group 1 实体）：
    - **作品（Work）**：一种独特的智力或艺术创作（如《哈姆雷特》）。
    - **内容表达（Expression）**：作品的具体实现形式（如英文原版、法语译本、有声读物等）。
    - **载体表现（Manifestation）**：内容表达的物理或数字载体（如某出版社 2020 年出版的平装本）。
    - **单件（Item）**：某一具体复本（如你图书馆里编号为 12345 的那本书）。
  - 还包括 Group 2（人/团体）和 Group 3（主题概念）等关联实体。

#### 2. FRAD（Functional Requirements for Authority Data）

- **中文名称**：规范数据的功能需求
- **提出时间**：2009 年，同样由 IFLA 发布
- **目的**：扩展 FRBR 模型，专门处理规范控制（authority control）中的实体（如作者、机构、会议等）及其相互关系。
- **核心实体**：Person（个人）、Corporate Body（团体）、Family（家族）、Concept（概念）、Place（地点）等。
- **作用**：解决“谁做了什么”“在哪里发生”等问题，支持更精细的语义链接。

#### 3. RDA（Resource Description and Access）

- **中文名称**：资源描述与检索
- **推出时间**：2010 年正式发布（取代 AACR2）
- **性质**：一套具体的编目规则（content standard），用于指导如何根据 FRBR 等模型来描述资源。
- **依据**：RDA 的设计直接基于 FRBR 和 FRAD 的概念模型。
- **特点**：
  - 采用“实体-属性-关系”结构；
  - 强调语义化、机器可读性（支持关联数据 Linked Data）；
  - 使用“元素集”（如 `rdaw:Work`, `rdac:Agent`）进行描述；
  - 与 BIBFRAME、Schema.org 等现代元数据框架兼容。

---

### 二、三者之间的关系

| 层面         | FRBR / FRAD                                  | RDA                                  |
| ------------ | -------------------------------------------- | ------------------------------------ |
| **性质**     | **概念模型**（理论框架）                     | **应用标准**（操作指南）             |
| **作用**     | 回答“书目世界由哪些实体构成？它们如何关联？” | 回答“如何具体描述这些实体及其属性？” |
| **依赖关系** | 无依赖（独立提出）                           | **依赖 FRBR/FRAD** 作为理论基础      |
| **输出形式** | 抽象的实体-关系图                            | 具体的编目规则、元素定义、示例       |

简言之：

- **FRBR/FRAD 提供“世界观”**：定义了书目宇宙中的基本构件（作品、表达、载体、人、概念等）及其关系。
- **RDA 提供“操作手册”**：告诉编目员如何用标准化的方式去描述这些构件。

> 类比：FRBR 像是“建筑蓝图”，RDA 则是“施工规范”。

---

### 三、主要区别总结

| 维度                   | FRBR / FRAD                  | RDA                                                |
| ---------------------- | ---------------------------- | -------------------------------------------------- |
| **类型**               | 概念模型（Conceptual Model） | 编目规则（Cataloging Standard）                    |
| **制定机构**           | IFLA（国际图联）             | JSC（联合指导委员会，现为 RDA Steering Committee） |
| **目标用户**           | 系统设计者、理论研究者       | 编目员、元数据专家                                 |
| **是否可直接用于编目** | 否（太抽象）                 | 是（提供具体指令）                                 |
| **是否包含语法**       | 否                           | 是（定义元素、取值、编码方式）                     |
| **是否支持关联数据**   | 隐含支持（通过实体关系）     | 显式支持（RDA Toolkit 支持 RDF、BIBFRAME 映射）    |

---

### 四、实际应用中的协同

在现代图书馆系统中：

1. **MARC 记录** 正逐步向 **BIBFRAME** 或 **RDF** 转型；
2. **RDA 规则** 被用于生成符合 FRBR 模型的元数据；
3. **FRBR 化显示**（如 WorldCat 的“作品视图”）允许用户按“作品”聚合不同版本；
4. **规范控制** 通过 FRAD 指导，确保“J.K. Rowling”不会被误认为多个不同作者。

---

### 五、常见误解澄清

- ❌ “RDA 就是 FRBR。”  
  ✅ 错。RDA 是基于 FRBR 的规则，但二者性质不同。

- ❌ “用了 RDA 就自动实现了 FRBR。”  
  ✅ 不一定。只有当系统能识别并分离 Work/Expression/Manifestation 层次时，才算真正 FRBR 化。

- ❌ “FRBR 取代了 MARC。”  
  ✅ 错。FRBR 是模型，MARC 是格式。RDA 可用 MARC21 编码，也可用 RDF。

---

### 六、发展趋势

- **BIBFRAME**（由美国国会图书馆主导）正在成为 FRBR 思想在关联数据环境下的新实现；
- **RDA Toolkit** 持续更新，强化与 Schema.org、Wikidata 等外部知识库的互操作；
- 图书馆目录正从“记录为中心”转向“实体为中心”的发现系统。

---

### 结语

FRBR（及 FRAD）提供了理解书目世界的 **语义骨架**，而 RDA 则是在这个骨架上填充 **血肉** 的具体方法。三者共同推动图书馆编目从传统的“卡片目录思维”迈向语义网时代的 **知识组织体系**。

---

### 💭 思考题  
1. 🤔 为什么 FRBR 将“作品”与“载体表现”分离？这对用户检索有何实际帮助？  
2. 🔍 RDA 强调“Access”而非“Retrieval”，这反映了怎样的用户中心思想？  
3. 🔄 举例说明：在图书馆 OPAC 中，如何通过 FRBR 模型将《红楼梦》的不同译本、版本、影印本聚合展示？  
4. 🧩 为什么说 RDA 是“独立于格式”的？它如何同时支持 MARC 和关联数据？

### 📝 论述题  
1. 🌐 试论述 FRBR 如何从“以记录为中心”转向“以用户任务为中心”，并分析其对现代发现系统（如 WorldCat、Summon）设计的影响。  
2. 🧱 “FRBR 提供骨架，RDA 填充血肉。”请结合 FRAD 的作用，深入分析三者如何协同构建下一代图书馆知识组织体系。  
3. ⚖️ 有人认为：“RDA 过于复杂，小馆难以实施。”你是否同意？请从 RDA 的灵活性、模块化设计及工具支持角度进行辩证分析。



# 第四章：图书的描述 📖

好，在图书描述的时候，大家注意一下，第四章一百二十六页，我们之前一直讲，中文描述的几个主要的注意项，大家一定要清楚。这个4.1的基本著录项目，大家一定要明确，一定要清楚。还有包括之前我们给大家讲过的这个SBD的八大著录项，其实大家不需要去记具体的字段，比方说**510**这个字段是什么意思（实际上是并列题名字段，可惜教材上没有看到520字段），不需要去记这些比较细的字段。但是最起码大家要知道，我们的这个比方说ISBD的八大著录项，大家一定要知道，这个具体的著录项是什么。然后这里有一个需要大家比较动点脑筋的，就是一百七十页。其实这个和我们之前这里只是讲这个字段，从编说明，什么时候集中著录，什么时候分散著录。

重点  
📍 P126 → 掌握 **中文图书描述的核心要点**  
📍 4.1 → 明确 **ISBD 八大著录项目**（无需死记字段号，如 `510`）  
📍 P170 → 理解 **集中著录 vs 分散著录** 的判断逻辑（尤其从编、分卷题名）

---

## 概念 💡

依据标准：

1. 🌍 **ISBD**（《国际标准书目著录》）  
2. 🇨🇳 《中国文献编目规则》  

🎯 目的：揭示图书的 **内容特征** & **形式特征**

---

## 价值 ✨

1. 📌 准确反映图书信息  
2. 🗂️ 帮助图书馆揭示馆藏  
3. 🧩 实现馆藏有序管理  
4. 🔍 方便读者检索

---

## 原则 📏（《CALIS 联机合作编目手册》）

1. 📋 **著录项目**  
   1. 🧱 统一的 **八大著录项目**（见 [:arrow_down:](#八大著录条目)）

2. 🔤 **著录用文字**  
3. 🔠 **著录用标识符**  
4. 👤 **著录信息源**  
5. 🧵 **集中著录 与 分散著录**  
   1. 📚 分卷题名 **有检索意义** → **分散著录**  
   2. 📖 从编 → **多数分散著录**  
   3. 🔄 其他情况 → **一般集中著录**

---

## 细节 🔧

参见 [CNMARC](#CNMARC) → 本章 = MARC 的具体应用  
📎 可参考 PPT（虽不考细节，但有助于理解）

### 随机字段示例：

- `001` —— 🆔 **记录控制号**  
  - 🏷️ CALIS 联合目录分配的唯一标识  
  - ✅ 必备 ｜❌ 不可重复 ｜🚫 无指示符 ｜🚫 无子字段  
  - 🤖 系统自动生成

- `010` —— 📇 **ISBN 字段**  
  - 📚 记录 ISBN + 获得方式（价格等）  
  - ⚖️ 有则必备 ｜🔁 可重复（多 ISBN 时）

| **子字段** | **名称**        | **说明**                                            |
| ---------- | --------------- | --------------------------------------------------- |
| `$a`       | 📇 ISBN          | ✅ 有则必备 ｜❌ 不可重复 ｜ 含连字符                    |
| `$b`       | 🎀 限定/装帧     | ✅ 有则必备 ｜❌ 不可重复 ｜ 精装/线装需著录，平装可省略 |
| `$d`       | 💰 获得方式/价格 | ✅ 有则必备 ｜❌ 不可重复 ｜ 格式：`CNY59.00`            |
| `$z`       | ❌ 错误 ISBN     | ✅ 有则必备 ｜🔁 可重复                                |

- `100` —— ⚙️ **一般数据处理字段**  
  ![100 字段图](https://suxiaomin-tuil.oss-cn-wuhan-lr.aliyuncs.com/typora/20260104114608328.png)

## 八大著录条目 📋

> 🌐 **ISBD** = IFLA 制定 → 目标：**国际一致性 & 数据交换**

### 一、ISBD 八大著录条目（图书）

| #    | 著录项             | CNMARC | 内容                           |
| ---- | ------------------ | ------ | ------------------------------ |
| 1    | 🆔 题名与责任说明项 | `=200` | 正题名 ｜ 并列题名 ｜ 责任者       |
| 2    | 📅 版本项           | `=205` | 第 3 版 ｜ 修订版等                |
| 3    | 📊 文献特殊细节项   | `=206` | 地图比例尺等（📚 图书通常省略） |
| 4    | 🏢 出版发行项       | `=210` | 出版地 ｜ 出版者 ｜ 出版年         |
| 5    | 📏 载体形态项       | `=215` | 页数 ｜ 尺寸 ｜ 附件（如光盘）     |
| 6    | 📌 丛编项           | `=225` | 丛书名 ｜ISSN｜ 编号             |
| 7    | 💬 附注项           | `=3XX` | 内容提要 ｜ 读者对象等           |
| 8    | 🔖 标准号及获得方式 | `=010` | ISBN｜ 价格                     |

> ✨ ISBD 标点（如 `.—` `:`）由系统自动生成，编目员只填内容。

---

### 二、CNMARC 实现（图书）

#### 1. `200` —— 🆔 题名与责任说明  
- `$a`：正题名  
- `$d`：并列题名（英文等）  
- `$e`：副题名  
- `$f`：第一责任者  
- `$g`：其他责任者  
- 📌 指示符 1：`1` = 有并列题名 ｜ `0` = 无

#### 2. `205` —— 📅 版本项  
- `$a`：版本说明（“第 3 版”）  
- `$b`：修订者（“张伟修订”）

#### 3. `206` —— 📊 特殊细节（图书通常不用）

#### 4. `210` —— 🏢 出版发行  
- `$a`：出版地  
- `$c`：出版者（⚠️ CNMARC 用 `$c`，非 `$b`）  
- `$d`：出版年

#### 5. `215` —— 📏 载体形态  
- `$a`：页数（“286 页”）  
- `$c`：插图（“图”）  
- `$d`：尺寸（“26cm”）  
- `$e`：附件（“附光盘 1 张”）

#### 6. `225` —— 📌 丛编项  
- `$a`：丛编题名  
- `$v`：编号（“第 5 册”）  
- `$i`：ISSN  
- 📌 指示符 2：`2` = 有编号

#### 7. `3XX` —— 💬 附注项  
| 字段  | 类型       |
| ----- | ---------- |
| `300` | 一般附注   |
| `327` | 内容提要   |
| `330` | 摘要       |
| `304` | 责任者附注 |

---

### 三、总结对照表 🔄

| ISBD 项           | CNMARC 字段       |
| ----------------- | ----------------- |
| 1. 题名与责任说明 | `200`             |
| 2. 版本项         | `205`             |
| 3. 特殊细节项     | `206`（省略）     |
| 4. 出版发行项     | `210`             |
| 5. 载体形态项     | `215`             |
| 6. 丛编项         | `225` / `410–430` |
| 7. 附注项         | `300, 327...`     |
| 8. 标准号         | `010`             |

---

## 款目连接块字段 🔗

### `410` —— 📚 **丛编连接字段**

- 📌 **定义**：当文献为单册或附属丛编时，用于连接 **文献 ↔ 所属丛编**（层次关系）  
- ✅ **有则必备** ｜🔁 **可重复**  

- 🔄 当 `225` 字段 **指示符 1 = 0 或 2**（提供检索点）时：  
  - 必须包含对应 `410` 字段  
  - 必须建立 **丛编规范记录**  
  - `410` 中的丛编名称必须是 **规范名称**  

- 📦 若文献隶属 **多种丛编** → 重复 `225` + `410`

---

### 💭 思考题  
1. 🤔 为什么普通图书通常 **不使用** `206` 字段？它更适合哪类资源？  
2. 🔍 `225` 与 `410` 字段的关系是什么？为何需要“规范名称”？  
3. 📏 在 `215` 字段中，“附光盘 1 张”应著录于哪个子字段？这体现了 MARC 对 **复合载体** 的何种处理逻辑？  
4. 🔄 集中著录与分散著录的核心区别是什么？请以一套多卷本学术著作为例说明何时应选择分散著录。

### 📝 论述题  
1. 🌐 试分析 ISBD 的八大著录项如何通过 CNMARC 字段实现“**形式标准化**”与“**机器可读性**”的统一，并讨论其在跨库检索中的作用。  
2. ⚖️ “CNMARC 的字段设计既继承了 ISBD 的结构，又为 FRBR 实体分离提供了可能。”请结合 `200`、`215`、`225` 等字段，论述这一观点是否成立。  
3. 🧩 在数字原生出版（如 EPUB、在线专著）日益普及的今天，ISBD 的八大著录项是否仍适用？请提出至少两项应调整或强化的著录要素，并说明理由。

# 第五章：元数据 📚


📍 **重点章节**，掌握元数据的基本概念、类型、特征及功能  
📍 P180 → 元数据基本概念  
📍 P183 → 元数据类型的划分（了解即可）  
📍 P186 → 元数据的特征  

---

## 概念 💡

- 📊 **Metadata** = 组织数字化信息的基本工具  
- 🧩 **关于数据的数据**  
- 📖 描述数据的数据  
- 🤔 可以理解为数据库中的 **Schema & table**（相对于 data）

> ❓ 为什么书评不能算是书的信息描述？  
> 📌 因为书评属于主观评价，而非客观描述，同时，书评也不够结构化。

---

## 类型 🗂️

### 结构与语义 🔍

- 📝 **简单格式元数据**：如 Elasticsearch 中的文档索引  
- 📊 **简单结构格式元数据**：如 关系型数据库  
- 🧬 **复杂结构格式元数据**：如 化学结构、基因图谱、地理空间信息

### 功能 🛠️

- 🛠️ **管理型元数据**  
- 📖 **描述型元数据**  
- 🗄️ **保存型元数据**  
- 🤖 **技术型元数据**  
- 👥 **使用型元数据**

### 专业性 🎓

- 并无绝对高下之分，但后者需要领域专家建立。  
- 🏷️ **非专业性元数据**：如 Dublin Core（DC），随发展各行业也建立了自己的标准  
- 📚 **专业性元数据**：如 MARC

### 应用领域 🌐

| 领域         | 示例              |
| ------------ | ----------------- |
| 科技文献     | BibTex, EELS      |
| 一般文献     | MARC, Dublin Core |
| 人文社科     | SGML, TEI Header  |
| 政府信息     | GILS              |
| 地理空间信息 | FGDC/CSDGM        |
| 网络信息     | **Dublin Core**   |

---

## 特征 ✨

1. **灵活性** -> 同一资源可用多种元数据描述，且支持多人合作、多角度描述  
2. **互操作性** -> 不同元数据格式应能相互转换  
3. **可扩展性** -> 核心集外可根据需求扩展  
4. **多语种**  
5. **描述性**  
6. **动态性**  
7. **支持性**

---

## 功能 🎯

### 资源描述功能 📋

- 对信息资源的 **内部特征** 和 **外部特征** 进行描述  
- 助于：
  - 🆔 **识别资源**
  - 📍 **定位资源**

### 资源索引功能 🔍

### 资源选择功能 ⚖️

- 基础了解和认识  
- 评估  
- 取舍与选择  
- 建立技术规范，实现分级制度（如 18+）

> 🔄 与 RDA 的功能类似：描述、索引、选择、获取

---

## 其他应用 🌍

- **社交网站**  
  - 社会标签（Tag）  
  - 资源定位  
  - 社会编目网站  

- **网络信息资源的揭示与描述**  
  - 基于 MARC  
  - 基于元数据 DC  

- **数据开放共享平台**  
- **语义网络的构建与知识发现**  
- **数字图书馆的建设与使用**  
- **各领域的元数据标准**  
  - 如美国的 **政府信息定位服务**（GILS）

---

### 💭 思考题  
1. 🤔 为什么说“书评”不属于书的信息描述？它与元数据有何本质区别？  
2. 🔍 在实际应用中，如何平衡元数据的 **灵活性** 与 **标准化** 之间的关系？请举例说明。  
3. 📏 “简单格式元数据”、“简单结构格式元数据”和“复杂结构格式元数据”在应用场景上有何不同？请结合具体实例分析。  
4. 📚 为什么说 Dublin Core 是非专业性元数据，而 MARC 是专业性元数据？这种分类对实际工作有何指导意义？

### 📝 论述题  
1. 🌐 试论述元数据的 **互操作性** 为何至关重要，并探讨当前跨系统、跨平台的元数据互操作面临的主要挑战及其解决策略。  
2. 🧩 在数字图书馆建设过程中，如何利用元数据的 **灵活性** 和 **可扩展性** 来满足不同类型用户的需求？请结合具体案例进行分析。  
3. 📖 “随着 DC 的发展，各行各业逐渐建立了自己的元数据标准。”请从这一现象出发，讨论元数据标准化的趋势及其对信息资源共享的影响。



# 第六章：资源描述框架

第六章 6.4 这里关于 RDF。我们首先要知道 RDF 的基本的原理和逻辑，包括它的概念和构成，大家要理解，也包括 RDF 的基本模型，大家要清楚。好，这个是 RDF。然后还有关于 RDF 的一些容器这块，大家要知道我们之前在很多实例当中都跟大家介绍过 RDF 有哪些容器，这些容器都是什么，有些是包，有些是顺序，

所以，重点是 RDF，但是，稍微了解一下 HTML 和 XML 也是很有价值的，因为，这会是我们接触非常广的两个东西。

## 标记语言

- 对网络信息资源进行描述的工具
- 在一个文本文件中使用一个代码集
- 用于指示计算机在打印机或者显示器上面编排文件的格式以及索引和链接信息

常见有

**SGML**（Standard Generalized Markup Language）

- 是 XML 和 HTML 的祖先，是一种元语言（用于定义其他标记语言）。
- 非常强大但复杂，主要用于大型文档系统（如军事、航空标准文档）。

**XML**（eXtensible Markup Language）

- SGML 的简化子集，强调 **结构化数据表示**。
- 主要用于 **数据交换**、配置文件、Web 服务等。
- 强调 **语义** 而非呈现（如何显示由外部样式表如 XSLT 控制）。

**HTML**（HyperText Markup Language）

- 最初基于 SGML，现在 HTML5 已不再严格遵循 SGML。
- 专为 **网页内容展示** 设计，兼顾语义与呈现。
- 浏览器直接解释并渲染。

**XHTML**

- XML 化的 HTML，语法更严格（所有标签必须闭合、属性加引号等）。

**SVG**（Scalable Vector Graphics）

- 一种基于 XML 的矢量图形描述语言。

## HTML

### 元素

HTML 结构：元素相互嵌套，

### 文档结构

```html
<!DOCTYPE html> 

<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>我的网页</title>
</head>
<body>
    <h1>欢迎来到我的网页！</h1>
    <p>这是一个简单的 HTML 示例。</p>
</body>
</html>
```

![img](https://www.runoob.com/wp-content/uploads/2013/06/02A7DD95-22B4-4FB9-B994-DDB5393F7F03.jpg)

HTML 标记标签通常被称为 HTML 标签 (HTML tag)。

1. HTML 标签是由 *尖括号* 包围的关键词，比如 `	 <html>`
2. HTML 标签通常是 *成对出现* 的，比如 <b> 和 </b>
3. 标签对中的第一个标签是 *开始标签*，第二个标签是 *结束标签*
4. 开始和结束标签也被称为 *开放标签* 和 *闭合标签*
5. 结束标签需要使用 `/`，但是不能使用属性
6. 标签没有内容的时候，也可以自闭合，如 `</br>`，也就是在 HTML 中表示换行语义的标签
7. 上述内容在 XML 中也适用。

### 特点

1. 简易性
   1. 把样式委托给 CSS
   2. 把逻辑委托给 JavaScript
   3. 通过 id 和 class 标记元素
2. 功能强大
   1. 可以链接多媒体资源和其他网页
   2. 感觉不比 Markdown 强大
   3. 等一下，Markdown 需要渲染成 HTML
   4. 嗯，功能强大。
3. 平台无关性
   1. 浏览器都可以使用
   2. 不需要特定的软件

## XML

1. 是 SGML 在特定应用领域的一个子集
2. 可以实现 SGML 的全部功能
3. 是 HTML 的补充和完善
4. 设计用来传输和存储数据
5. 没有预定义标签

### 特点

- 易用性
  - 领域无关
  - 可以用在网页（虽然很少）
  - 可以用在程序配置（虽然 Json 也可以）
  - 可以用在 Word 和电子书
- 可扩展性
  - 可以拓展标签
- 自描述性
  - 可以自定义元数据
  - 比 HTML 的 metadata 的效果更好
- 交互性
  - 语义丰富
  - 支持更复杂的功能
- 结构化
  - 可以使用 DTD 和 XML Schema
  - 严格语法规范
  - 不过，RDF 反而是不使用这种规范的
  - 可以使用命名域

### 结构

docx 就是基于 XML 实现的。

看一下 docx 的解压文件。

```bash
tree /f /a C:\A\ZGTD\信息行为分析\template
卷 OS 的文件夹 PATH 列表
卷序列号为 22D9-36C9
C:\A\ZGTD\信息行为分析\TEMPLATE
|   [Content_Types].xml
|
+---customXml
|   |   item1.xml
|   |   itemProps1.xml
|   |
|   \---_rels
|           item1.xml.rels
|
+---docProps
|       app.xml
|       core.xml
|       custom.xml
|
+---word
|   |   document.xml
|   |   fontTable.xml
|   |   footer1.xml
|   |   footer2.xml
|   |   footer3.xml
|   |   footnotes.xml
|   |   header1.xml
|   |   settings.xml
|   |   styles.xml
|   |
|   +---media
|   |       image1.jpeg
|   |       image2.png
|   |
|   +---theme
|   |       theme1.xml
|   |
|   \---_rels
|           document.xml.rels
|
\---_rels
        .rels
```



看一下基础的 `[Content_Types].xml`，

```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
    <Default Extension="xml" ContentType="application/xml" />
    <Default Extension="jpeg" ContentType="image/jpeg" />
    <Default Extension="JPG" ContentType="image/.jpg" />
    <Default Extension="png" ContentType="image/png" />
    <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />
    <Override PartName="/customXml/itemProps1.xml"
        ContentType="application/vnd.openxmlformats-officedocument.customXmlProperties+xml" />
    <Override PartName="/docProps/app.xml"
        ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml" />
    <Override PartName="/docProps/core.xml"
        ContentType="application/vnd.openxmlformats-package.core-properties+xml" />
    <Override PartName="/docProps/custom.xml"
        ContentType="application/vnd.openxmlformats-officedocument.custom-properties+xml" />
    <Override PartName="/word/document.xml"
        ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml" />
    <Override PartName="/word/fontTable.xml"
        ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml" />
    <Override PartName="/word/footer1.xml"
        ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml" />
    <Override PartName="/word/footer2.xml"
        ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml" />
    <Override PartName="/word/footer3.xml"
        ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml" />
    <Override PartName="/word/footnotes.xml"
        ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml" />
    <Override PartName="/word/header1.xml"
        ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml" />
    <Override PartName="/word/settings.xml"
        ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml" />
    <Override PartName="/word/styles.xml"
        ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml" />
    <Override PartName="/word/theme/theme1.xml"
        ContentType="application/vnd.openxmlformats-officedocument.theme+xml" />
</Types>
```

这个就是一个申明文档内容的 XML 文件。

我们再来看一下 core.xml，核心 XML

### core.xml

```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<cp:coreProperties
    xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties"
    xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/"
    xmlns:dcmitype="http://purl.org/dc/dcmitype/"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <dcterms:created xsi:type="dcterms:W3CDTF">2023-01-12T04:50:00Z</dcterms:created>
    <dc:creator>Liang Shaobo</dc:creator>
    <cp:lastModifiedBy>Su Xiaomin</cp:lastModifiedBy>
    <dcterms:modified xsi:type="dcterms:W3CDTF">2025-12-14T03:57:05Z</dcterms:modified>
    <cp:revision>13</cp:revision>
</cp:coreProperties>
```

1. 文档序言
   1. 也就是 `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>`
2. 文档元素
   1. 也就是后面的内容
   2. 可以自由嵌套
3. XML 属性
   1. 如 `xsi:type="dcterms:W3CDTF"`, 这里申明的就是 scheme，对于日期的编码方式。
4. XML 注释
   1. 和 HTML 一样，使用 `<!-- content -->` 的方式，

## XML 技术体系

### DTD

文档内容声明，简单地说，使用特定的语法对于 XML 进行规范。

DTD 不能很好地实现应用程序间不同模块的相互协调，缺乏对于文档结构、属性、数据类型的阅读。

内嵌 DTD 的 XML

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book [
  <!ELEMENT book (title, author, price)>
  <!ELEMENT title (#PCDATA)>
  <!ELEMENT author (#PCDATA)>
  <!ELEMENT price (#PCDATA)>
  <!ATTLIST price currency CDATA "CNY">
]>
<book>
  <title>深入理解计算机系统</title>
  <author>Randal E. Bryant</author>
  <price currency="CNY">139.00</price>
</book>
```

直接的 DTD 也就是开头那一团

```dtd
<!DOCTYPE book [
  <!ELEMENT book (title, author, price)>
  <!ELEMENT title (#PCDATA)>
  <!ELEMENT author (#PCDATA)>
  <!ELEMENT price (#PCDATA)>
  <!ATTLIST price currency CDATA "CNY">
]>
```

一般和 CSS 一样，都使用引用格式，而且，一般来说，这个都不会引用自己写的，因为 XML 的用途就是为了数据传输和共享，所以会使用默认的规范，会附带一个网址，可能会附带两个，一个是 URI（用作 DTD 的唯一标识，即使 DTD 更新了，这个标识也不会改变），一个是 URL（用作 DTD 的获取，指，从这个网址可以获取到当前使用的 DTD 内容）。



### Schema

XML Schema 是 XML 的标准模式。（这里是 schema，不是 scheme）

一般写起来就是 XML，这样就不需要再定义一种数据格式了。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           targetNamespace="http://example.com/book"
           xmlns:tns="http://example.com/book"
           elementFormDefault="qualified">

  <!-- 定义根元素 book -->
  <xs:element name="book" type="tns:BookType"/>

  <!-- 定义 BookType 复合类型 -->
  <xs:complexType name="BookType">
    <xs:sequence>
      <xs:element name="title" type="xs:string"/>
      <xs:element name="author" type="xs:string"/>
      <xs:element name="price" type="tns:PriceType"/>
    </xs:sequence>
  </xs:complexType>

  <!-- 定义 PriceType 简单类型，带 currency 属性 -->
  <xs:complexType name="PriceType">
    <xs:simpleContent>
      <xs:extension base="xs:decimal">
        <xs:attribute name="currency" type="xs:string" default="CNY"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

</xs:schema>
```

### 🔍 说明：

- **命名空间**：

  1. `targetNamespace="http://example.com/book"`：定义该 schema 所属的命名空间。
  2. `xmlns:tns="http://example.com/book"`：用 `tns` 前缀引用自己的命名空间。
  3. `elementFormDefault="qualified"`：要求所有局部元素都必须使用命名空间前缀（在实例文档中需声明）。

- **元素与类型**：

  1. `<book>` 是根元素，类型为 `BookType`。
  2. `BookType` 包含三个子元素：`title`、`author` 和 `price`，顺序固定。
  3. `price` 使用自定义类型 `PriceType`，它基于 `xs:decimal`，并添加了一个 `currency` 属性（默认值为 `"CNY"`）。

  

  对应的 XML 文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<book xmlns="http://example.com/book"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://example.com/book book.xsd">
  <title>深入理解计算机系统</title>
  <author>Randal E. Bryant</author>
  <price currency="CNY">139.00</price>
</book>
```

命名空间是 XML 中非常重要的一个概念，XML 的所有元素必须要属于一个命名空间。

XML 中可以申明多个命名空间，

形如 `<book>`，表示属于默认命名空间，即，直接通过 `xmlns="http://example.com/book"` 申明的命名空间，这里的 xmlns 没有冒号

形如 `<xsi:LschemaLocation>` 表示属于 xsi 命名空间，即，通过 `xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"` 申明的命名空间。

命名空间，不仅仅用在标签的申明上，乃至标签属性，也必须要申明，例外是，xmlns 这个属性，是 XML 的默认的 terms，不需要事先申明，它也是 XML 的灵魂。

xlmns 生一，一生二，二生三，三生万物。

### 编辑器

非考点，而是实验课的内容。

我建议使用 VS Code，搭配一个插件就可以了。

比下载 XML Spy 更方便，更好用。

顺便，注意文件名的命名，不要使用中文。

注意，文件的编码，还是使用 `encoding="UTF-8"`，养成好习惯，避免乱码问题。

## RDF

重点！

### 概念

资源描述框架， Resource Description Framework

一种用于描述 Web 资源的框架，是 W3C 语义网络活动的组成部分

可以使用 XML 进行编写，被使用的 XML 语言被称为 RDF/XML，

1. RDF Data Model
2. RDF Schema
3. RDF Syntax

### RDF Data Model

简单地说

资源 --属性--> 属性值

```mermaid
flowchart LR
r([资源（resource）]) --属性（property）--> v[ 属性值（value）]
```

这样一条描述被称为 RDF 陈述，RDF Statement

### RDF/XML 语法

只要记住以下几点就可以了

```xml
<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    
    <rdf:Description rdf:about="http://w3c.org/RDF">
        <dc:creator>David</dc:creator>
    </rdf:Description>
    
</rdf:RDF>
```

首先，需要申明这是一个 XML 文件

之后，需要定义顶级元素，`rdf:RDF`

这里，前面的 rdf 是命名空间，后面的 RDF 是这个命名空间的一个定义的元素，也就是我们的顶级元素。

这里就出现了一个逻辑上可能难以理解的地方，先申明元素，再申明元素的命名空间。换言之，元素出现在元素申明之前。就好像函数调用出现在函数定义之前，因为 XML 是整体进行解析的，先解析命名域，再解析元素。

它其实同时申明了两个命名空间，一个是 rdf 命名空间，另外一个是 dc 命名空间。

`rdf:about="http://w3c.org/RDF"`，这里的 about 属性，就是来表述要描述的对象，一般来说使用一个 URI。

里面就可以自由嵌入要描述的内容了，一般使用 dc 比较多，这是下一章的内容。

一个类似的元素是，`rdf:resource`，即，仅仅表示元素获取的途经，不表示元素的 URI。

### RDF/XML 的特性

1. 简单
  1. 比一般的 XML 要简单一些
  2. 因为它没有使用复杂的嵌套模式
  3. 实际上也没有使用 DTD 和 XSD、
  4. 因为 RDF 不需要特定的格式
2. 独立
  1. 自由申明命名空间
  2. RDF 没有限制
  3. 可以跨越元数据标准
3. 开放
  1. 可以自定义词汇集
  2. 扩展
  3. 可以在词汇集中自己添加元素
4. 交换
  1. XML 方便交换
5. 综合
  1. 使用三元组，实际上是一种链接
  2. 形成语义网络


### 容器机制

容器是用在 `rdf:Description` 标签内的。

使用

```xml
<rdf:Bag>
    <rdf:li>first</rdf:li>
    <rdf:li>second</rdf:li>
    <rdf:li>third</rdf:li>
</rdf:Bag>
```

可以封装多个无序元素。

使用

```xml
<rdf:Seq>
    <rdf:li>first</rdf:li>
    <rdf:li>second</rdf:li>
    <rdf:li>third</rdf:li>
</rdf:Seq>
```

可以封装多个多许元素。

使用

```xml
<rdf:Alt>
    <rdf:li>first</rdf:li>
    <rdf:li>second</rdf:li>
    <rdf:li>third</rdf:li>
</rdf:Alt>
```

可以表示多选一。

上述封装之后，都可以视作一个元素。

参考 [千问](https://www.qianwen.com/share?shareId=62aff202-6268-43bd-a8ea-6bb8a89c4807)

### RDF Schema

参考 [千问-RDF Schema](https://www.qianwen.com/share?shareId=936883d0-de2d-4637-af45-4290c58add3c)， 参见 [千问-RDF 实现](https://www.qianwen.com/share?shareId=adaf1831-b90f-4492-9d1d-7092af1a1dea)，确实有一点难以理解。

实际上，理解我们教材当中的 RDF Schema，也即基于 XML 的实现，就需要理解 XML Namespace，后者的作用是，区分不同应用领域的同名称，如，DC 当中的 creator 可能不同于 GMLS 中的 creator。使用同一套命名域，则保证我们对于语义的理解形成共识。（因为自然语义存在歧义，但是 RDF Schema 命名域中的语言是相对精准的）

RDFS 申明了如下的词汇

- Resource
- Class
- Property

可以这样理解，基于 XML 的 RDFS 是一套对于 XML 扩展，展现了 **基于类** 的资源描述。

RDFS 申明之后，就好像给 XML 加上了 面向对象（继承、封装、多态）的 DLC。但是，一般来说，我们进行的信息描述应该还用不上这么高级的知识。

# 第七章：DC 元数据

然后关于第七章，DC 元数据，基本概念大家要清楚。另外一个，就是我们之前讲了很多内容，关于 DC 元数据的修饰词，DC 元素这个元数据的修饰词大家一定要知道什么是 DC 元数据的修饰词，这个修饰词。好，然后呢，关于这个句法结构，7.4 有一个比较重要的概念，关于这个 DC 语言应用定义的纲要，这是我们之前上讲的了解一下。

## 概念

- 都柏林核心元素集，Dublin Core Elements Set
- 简单的，能够有效的描述网络资源
- 被用户所接受
- 可用于互操作的交换数据标准
  - 15 个元素
  - 术语体系与词表
  - 修饰词
  - 抽象模型
  - 应用纲要
- 适用于任何领域

## DCMI

都柏林核心元数据工作小组，简单地说，就是干事的机构。

## 原则

1. 内在本质原则
   1. 只描述与文件内容和实体相关的特性
2. 可扩展性原则
   1. 可以作为地区性规范
   2. 可以进行后续扩展
3. 可选择性原则
4. 可重复性原则
5. 可修饰性原则
   1. 可以使用修饰词
   2. 修饰词可以独立存在
6. 句法独立原则
   1. 句法简单
   2. 可以基于各种置标语言
   3. 结构平面
   4. 顺序无关

## 元素

### 内容

- title
- subject
- description
- source
- language
- relation
- coverage

### 知识产权

- creator
- publisher
- contributor
- rights

### 外部属性

- date
- type
  - text
  - image
  - sound
  - dataset
  - software
- format
  - "text/html"
  - "Video/mpeg"
  - "Video/mp4"
- identifier
  - URI
    - URN
    - URL
  - ISBN
  - ISSN

注意，这里怎么区别 type 和 format 呢？

type 是对于人类易于感知的区分，如，人类可以区分音频和视频和文本的差异

format 是这种区分之于计算机的存储或者表现形式，往往是 type 的细化，同时也是对于格式进行约定。

什么是 identifier 呢？可以理解成资源的身份证。URI 就是 统一资源标识符，也就是全球唯一的身份证的含义。

小问题：如果你想要描述的字段不在上面，应该怎么办？

结论是，使用 dcterms，dcterms 的词表远远比上面 15 个词汇要丰富。而且 dcterms 也承担更丰富的语义。

### HTML 示例

使用 HTML，一般可以表现为以下的形式

```html
<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <!-- 声明 dcterms 命名空间 -->
    <link rel="schema.dcterms" href="http://purl.org/dc/terms/" />

    <!-- 标题（人类可读） -->
    <title>信息描述 - 吴丹 著</title>

    <!-- DCMI 元数据 -->
    <meta name="dcterms.title" content="信息描述" lang="zh" />
    <meta name="dcterms.creator" content="吴丹" lang="zh" />
    <meta name="dcterms.publisher" content="武汉大学出版社" lang="zh" />
    <meta name="dcterms.date" content="2022" scheme="DCTERMS.W3CDTF" />
    <meta name="dcterms.type" content="Text" scheme="DCTERMS.DCMIType" />
    <meta name="dcterms.format" content="application/pdf" scheme="DCTERMS.IMT" />
    <meta name="dcterms.language" content="zh" scheme="DCTERMS.RFC4646" />
    <meta name="dcterms.subject" content="信息组织" lang="zh" />
    <meta name="dcterms.subject" content="元数据" lang="zh" />
    <meta name="dcterms.subject" content="都柏林核心" lang="zh" />
    <meta name="dcterms.subject" content="编目" lang="zh" />
    <meta
      name="dcterms.description"
      content="本书系统介绍信息描述的基本理论、方法与应用，涵盖MARC、DC、RDA等主流元数据标准，适用于图书情报学专业教学与研究。"
      lang="zh"
    />
    <meta name="dcterms.identifier" content="ISBN:978-7-307-22450-6" />
    <meta name="dcterms.relation" content="武汉大学信息管理学院教材系列" />
    <meta name="dcterms.coverage" content="中国" lang="zh" />
    <meta name="dcterms.rights" content="© 武汉大学出版社 2022" lang="zh" />
    <!-- 若有开放许可，应优先用 dcterms.license + 官方URI -->
    <!-- <meta name="dcterms.license" content="https://creativecommons.org/licenses/by-nc-nd/4.0/"> -->

    <!-- 可选：兼容旧系统，提供 dc 前缀（不推荐新增项目使用） -->
    <!--
  <link rel="schema.dc" href="http://purl.org/dc/elements/1.1/">
  <meta name="dc.title" content="信息描述">
  <meta name="dc.creator" content="吴丹">
  <meta name="dc.publisher" content="武汉大学出版社">
  --></head>
  <body>
    <!-- 页面内容 -->
  </body>
</html>

```

## 修饰词

限定，即，对于未修饰的 15 个核心元素的语义，进行限定和修饰

- 语种
- 模式
- 类型

组成

- 控制词汇
- 编码体系

实现

- 元素限定词
  - 缩小元素的含义范围
  - 专指性
- 编码体系修饰词
  - 限定值的语义结构
  - 基于 词表 or 句法

可以这样理解，元素修饰词是对于语义的控制，编码体系是对于语法和词汇（即，语义结构）的控制。

例如，

- title（题名）
  - 只存在元素修饰词（元素限定词），即 Alternative，
  - 因为无法对于语法和词汇进行限制。
- subject
  - 不存在元素限定，主题范畴唯一。
  - 只存在编码体系修饰词。旨在提高互操作性（即，使用同一套编码体系得到的元数据对于彼此有着参考的价值）
  - 也即，主题词表
- date
  - 存在元素限定词，即，何种日期（创建？修改？可获得？发行？）
  - 存在编码体系修饰词，即，按照何种语法表示时间（即，date format）
- relation
  - 存在大量元素修饰词，因为 relation 本身是模糊的
  - 如 `<dcterms:Requires>` or `<dcterms:isRequiredBy>`
  - 如 `<dcterms:isPartOf>`  or `<dcterms:hasPart>`
- coverage
  - 进一步细分为
  - Spatial
  - Temporal

- 在此基础上进行编码体系修饰。

以上仅仅基于我的理解。我不确定在教材之外，是否以上元素还存在其他的修饰词。

元素修饰词，可以从两个角度来理解，可以理解成，它们是对于原始的十五个范畴的细化和限制，也可以理解成，原始的十五个范畴本身根本不够使用，所以需要更多的范畴来对于对象进行描述，于是，也无所谓，修饰，因为，本即不需要继承。值得一提的是，DC 更偏好使用 dcterms 这样细化的命名空间，而非使用 dc.title.alternative 这样的修饰词。见下 [:arrow_down:](#`dc` 与 `dcterms` 的区别)

属性

1. Name

2. Label

3. Definition

4. Comment

5. See Also


## DC 描述原则

1. 向上兼容
2. 一对一
3. 恰当

## Relation

在都柏林核心（Dublin Core，简称 DC）元数据标准中，**Relation** 字段用于描述资源与其他资源之间的关系。它是 15 个核心元素之一，属于“描述性”类别，主要用于表达当前资源与一个或多个外部资源之间的关联。

---

### 一、Relation 字段的基本定义

- **元素名称（Element Name）**：Relation  
- **URI**：http://purl.org/dc/elements/1.1/relation  
- **定义（Definition）**：与当前资源存在某种关系的另一个资源的引用。  
- **可重复性**：是（可以出现多次）  
- **是否必须**：否（可选字段）

Relation 元素本身是一个通用的关系描述符，通常需要配合 **修饰词（qualifiers）** 来更精确地说明关系类型。

---

### 二、Relation 的常见用途

Relation 可用于表示以下类型的关联：

- 衍生关系（如翻译、改编、摘要）
- 集合关系（如属于某丛书、系列、数据库）
- 版本关系（如前一版本、后续版本）
- 补充材料（如附录、数据集、代码）
- 引用关系（如引用了某篇论文）

例如：

- 一篇论文 Relation 到其原始数据集；
- 一本图书 Relation 到其所属的丛书；
- 一个网页 Relation 到其 PDF 格式副本。

---

### 三、Relation 的修饰词（Qualifiers）

DC 允许使用 **限定词（qualifiers）** 对核心元素进行细化。对于 Relation，常见的限定词来自 DCMI（Dublin Core Metadata Initiative）推荐的词汇表，尤其是 **DCMI Type Vocabulary** 和 **DCMI Relation Terms**。

#### 1. 官方推荐的 Relation 限定词（DCMI Relation Vocabulary）

DCMI 定义了一组标准化的关系类型，作为 Relation 元素的限定词。这些限定词具有明确语义，便于机器理解和互操作。主要类型包括：

| 限定词（Qualifier） | URI                                     | 含义                                                         |
| ------------------- | --------------------------------------- | ------------------------------------------------------------ |
| **IsVersionOf**     | http://purl.org/dc/terms/isVersionOf    | 当前资源是另一资源的新版本（如修订版、更新版），但本质内容相同。 |
| **HasVersion**      | http://purl.org/dc/terms/hasVersion     | 当前资源有其他版本存在。                                     |
| **IsReplacedBy**    | http://purl.org/dc/terms/isReplacedBy   | 当前资源已被另一资源取代。                                   |
| **Replaces**        | http://purl.org/dc/terms/replaces       | 当前资源取代了另一资源。                                     |
| **IsRequiredBy**    | http://purl.org/dc/terms/isRequiredBy   | 当前资源被另一资源所依赖（如标准文档被产品规范引用）。       |
| **Requires**        | http://purl.org/dc/terms/requires       | 当前资源依赖于另一资源（如软件需要某个库）。                 |
| **IsPartOf**        | http://purl.org/dc/terms/isPartOf       | 当前资源是另一更大资源的一部分（如期刊文章属于某期期刊）。   |
| **HasPart**         | http://purl.org/dc/terms/hasPart        | 当前资源包含其他资源作为组成部分（如合集包含多篇文章）。     |
| **IsReferencedBy**  | http://purl.org/dc/terms/isReferencedBy | 当前资源被另一资源引用（如论文被综述文章引用）。             |
| **References**      | http://purl.org/dc/terms/references     | 当前资源引用了另一资源（如参考文献）。                       |
| **IsFormatOf**      | http://purl.org/dc/terms/isFormatOf     | 当前资源是另一资源的格式转换（如 PDF 是 HTML 的另一种格式）。    |
| **HasFormat**       | http://purl.org/dc/terms/hasFormat      | 当前资源有其他格式存在。                                     |
| **IsDerivedFrom**   | http://purl.org/dc/terms/isDerivedFrom  | 当前资源由另一资源派生而来（如翻译、改编、可视化）。         |
| **Source**          | http://purl.org/dc/terms/source         | （较宽泛）当前资源来源于某原始资源。                         |

> ⚠️ 注意：虽然 "Source" 有时被用作 Relation 的限定词，但它本身也是一个独立的 DC 元素（dc: source），语义略有不同。建议优先使用上述 DCMI 关系术语。

---

### 四、使用示例（XML/RDF 格式）

使用 dcterms。

#### 示例 1：使用 IsPartOf

```xml
<dc:relation>
  <dcterms:isPartOf>https://example.org/journal/vol12</dcterms:isPartOf>
</dc:relation>
```

或简写（若上下文支持）：

```xml
<dcterms:isPartOf>Journal of Digital Humanities, Vol. 12</dcterms:isPartOf>
```

#### 示例 2：使用 References

```xml
<dcterms:references>https://doi.org/10.1234/abcd123</dcterms:references>
```

#### 示例 3：普通 Relation（无限定词）

```xml
<dc:relation>Related dataset available at https://data.example.com/ds001</dc:relation>
```

> 这种方式语义模糊，不推荐用于结构化数据交换。

---

### 五、最佳实践建议

1. **优先使用 DCMI 定义的关系限定词**，而非裸用 `dc:relation`，以增强语义清晰度和互操作性。
2. **关系值应尽量使用 URI 或持久标识符**（如 DOI、Handle、ARK），而非仅文本描述。
3. **避免循环引用或歧义**：确保关系方向正确（如 A `replaces` B，则 B 应 `isReplacedBy` A）。
4. **结合其他元数据元素使用**：如与 `Identifier`、`Title`、`Source` 等配合，提供完整上下文。

---

### 六、相关标准与扩展

- **DC Terms（DCTERMS）**：DCMI 推荐使用 `http://purl.org/dc/terms/` 命名空间下的限定词，而非旧的 `dc:` 命名空间。
- **Schema.org / OWL / RDF**：在语义网环境中，DC Relation 可映射到更丰富的本体关系（如 `dct:isPartOf` ≈ `schema:isPartOf`）。

---

### 总结

| 要点                  | 说明                                                         |
| --------------------- | ------------------------------------------------------------ |
| **Relation 元素作用** | 描述资源间的关联                                             |
| **是否需限定词**      | 强烈建议使用，否则语义模糊                                   |
| **常用限定词**        | isPartOf, hasPart, isVersionOf, references, isDerivedFrom 等 |
| **值格式建议**        | 使用 URI/DOI 等持久标识符                                    |
| **命名空间**          | 推荐使用 `dcterms:` 而非 `dc:`                               |

通过合理使用 Relation 及其限定词，可以显著提升数字资源的关联性、可发现性和语义丰富度，尤其在数字图书馆、学术出版、开放数据等领域具有重要价值。

## 元数据体系

- 句法
  - 描述元数据是如何被表述的，
  - 如，date format，描述如何表述一个日期
- 语义
  - 内容实体
  - 元素的定义
- 结构
  - 描述整体框架，不同元数据之间的相互关系



## DC 词表

参见 P280 页。也即，各种 type。

![image-20260102090059217](https://suxiaomin-tuil.oss-cn-wuhan-lr.aliyuncs.com/typora/20260102092647298.png)

以上资源均在词表当中有定义。

1. Collection
2. Dataset
3. Event
4. Image
   1. 广义的 Image，即，非 Text 之外的可视化表现
5. StillImage
   1. Image 的子类
6. MovingImage
   1. Image 的子类
7. InteractiveResource
8. PyhsicalObject
9. Service
10. Software
11. Sound
12. Text

## DCMI 抽象模型

什么是抽象模型？

抽象模型用来表示资源之间的相对关系，它超越了具体某一个资源的限定

可以使用 E-R 图来展示

### 资源

- 资源
- 属性
- 值
- 类

简述相关关系，

一个类对应多个资源

一个资源对应多个属性

一个属性对应一个值

类和类可以相关

按照语义

一个资源可以对应多个类

一个值可以对应多个属性

### 描述

一个描述（Description）对应多个陈述（Statement），至多一个 URI

一个陈述对应一个属性 URI，至多一个值 URI，至多一个编码体系 URI，任意个表述。

（所谓 URI，即 Identifier，用来唯一标识一个对象，可以理解成编程中的类，但是这里使用特定格式的字符串而非物理内存中的地址来确定唯一性，即，属性 URI，区别于属性文本，后者只具有理解的语义，而不具备定位的价值。信息描述的特点在于，使用结构语义来超越文本语义，实现复杂的建模。

属性 URI，如，头发颜色，值 URI，如 BLACK，使用#000000 进行编码。）

属性可以对应多个陈述

值内容可以使用

- 字符串
  - 需要有编码格式，即，如何被计算机存储
  - 需要有语种，即，如何被解释。
- 复合值
  - 如视频、音频，乃至组合
- 相关描述
  - 过于抽象，不太理解
  - 相关描述不是描述的一部分，而是描述的值的一部分
  - 值可以有 URI，相关描述，描述的是值对应的 URI，而非原始对象
  - 如，book 的 dcterms: creator 有值 URI，其相关描述，描述的是 creator。

### 值

参考前面的内容，需要注意的是，无论值采取怎样的方式，值的本质是一个资源

如，前面

`<dc:creator>Liang Shaobo</dc:creator>`

虽然这里没有提供其 [URI](https://sim.whu.edu.cn/info/1560/12945.htm)，但是，其实质依旧是一个资源，而非字符串，我们仅仅使用字符串来展现语义，虽然这种语义对于机器来说没有太大的识别的价值。

## 应用纲要

**重点**，看教材，也非常抽象。

### 一、Dublin Core

**都柏林核心（Dublin Core Metadata Initiative, DCMI）** 是一个国际性的标准化组织，致力于开发和维护用于描述数字资源的 **通用元数据标准**。其最著名成果是 **Dublin Core 元数据元素集（DCMES）**，包含 15 个核心元素，如：

- Title（标题）  
- Creator（创建者）  
- Subject（主题）  
- Description（描述）  
- Publisher（发布者）  
- Date（日期）  
- Type（类型）  
- Format（格式）  
- Identifier（标识符）  
- Source（来源）  
- Language（语言）  
- Relation（关联）  
- Coverage（覆盖范围）  
- Rights（权利）

这些元素被广泛应用于图书馆、档案馆、博物馆、教育平台等领域的资源发现与互操作。

---

### 二、什么是“应用纲要”（Application Profile, AP）？

在 DCMI 框架中，**应用纲要（AP）** 是一种 **元数据使用规范**，它定义了：

- 在特定应用场景下应使用哪些元数据元素；
- 这些元素的语义约束（如取值范围、编码方案）；
- 元素之间的关系；
- 如何组合来自不同命名空间的元素（如 DC + FOAF + SKOS 等）。

> **AP 的目标**：在保持互操作性的同时，满足特定社区或系统的描述需求。

---

### 三、DC CD AP：都柏林核心集合描述应用纲要

#### 全称：

**Dublin Core Collection Description Application Profile (DC CD AP)**

#### 目标：

> **为“资源集合”（如数字图书馆中的馆藏、数据库、档案全宗、网站栏目等）提供一种简单、一致、可互操作的描述方法**，尤其支持对 **集合层次结构**（如父集合-子集合）的表达。

#### 核心问题解决：

- 单个资源（如一篇文章）可用标准 DC 描述；
- 但 **成百上千资源组成的集合**（如“民国期刊数据库”）也需要被描述和发现；
- 集合本身可能有管理者、访问策略、更新频率、包含关系等属性；
- DC CD AP 正是为了描述这类“集合级元数据”（collection-level metadata）。

---

### 四、DC CD AP 的关键特点

#### 1. **聚焦“集合”而非单个资源**

- 描述对象是 `Collection`（集合），属于 DC 的 `Type` 元素的一个取值。
- 支持描述集合的名称、目的、内容范围、管理机构、访问方式等。

#### 2. **支持层次结构**

- 使用 `isPartOf` 和 `hasPart` 属性表达集合之间的包含关系。
  - 例如：“华东地区地方志” **isPartOf** “中国地方志总库”
  - “中国地方志总库” **hasPart** “华东地区地方志”

#### 3. **复用并扩展 DC 元素**

- 主要基于 15 个 DC 核心元素；
- 同时引入 DCMI 类型词汇表（DCMI Type Vocabulary）中的 `Collection` 类型；
- 可选结合其他命名空间（如 `dcterms:accrualPeriodicity` 表示更新频率）。

#### 4. **强调实用性与简洁性**

- 避免过度复杂化，适合中小型机构快速部署；
- 可用于 OPAC（联机公共检索目录）、OAI-PMH 数据提供者、数字仓储系统等。

---

### 五、DC CD AP 的典型应用场景

| 场景         | 说明                                   |
| ------------ | -------------------------------------- |
| 数字图书馆   | 描述“古籍善本库”“学位论文库”等馆藏集合 |
| 档案管理系统 | 描述“某企业全宗档案”及其子系列         |
| 教育资源平台 | 描述“高中物理课程资源包”               |
| 文化遗产项目 | 描述“丝绸之路数字博物馆”的各个展区集合 |
| 联邦检索系统 | 通过集合级元数据聚合多个数据源         |

### 总结

| 术语         | 含义                                           |
| ------------ | ---------------------------------------------- |
| **DC**       | Dublin Core，通用元数据标准                    |
| **CD AP**    | Collection Description Application Profile     |
| **DC CD AP** | 用于描述资源集合及其层次结构的元数据应用纲要   |
| **目标**     | 让“集合”也能像单个资源一样被发现、管理和互操作 |



### 概念

- 资源集合
  - 对象的集合体
  - 任意物理、数字化的对象集合
  - 如，图书馆书目资源
- 对象
  - 内容的具体实现
  - 如，书
- **资源集合层级描述**
  - 将资源集合视作整体
  - 在该层次（而非对象层级）进行描述

- 位置
  - 资源集合放置和获取的位置
  - 如，图书馆
- 服务
  - 提供访问资源的系统
  - 如，图书馆访问系统
- 描述
  - 描述资源集合的资源
  - 如，MARC

都柏林核心资源 集合描述 应用纲要 （ DC CD AP）致力于 提供一种简单的对于 **资源集合** 和 **资源集合层次描述** 的方法。

目标：

- 检索与发现
- 标识内容
- 选择资源
- 标识位置
- 提供服务

### 词表 or 命名域

1. dc
2. dcterms
3. dcmitype
4. marcel
5. cld
6. cdtype

### DC-Lib

DC 图书馆应用纲要，也就是为图书馆特化了一下。

类似还有

- DC-Goverment
- DC-Education

可以看出来 DC 的可扩展性。

## 应用

### DC 支持数字博物馆建设

数字博物馆：将自身文物、标本藏品、陈列展示 采用计算机技术进行处理、加工、整序并且上网供公共浏览的多媒体信息机构

数字化的过程中，对于藏品和数字化资源进行描述与标引，生成了数字博物馆的元数据。

DC 可以用于描述图形图形等相关信息

可以改造并且移植于博物馆数字化工作。

### DC 与开放数据共享

参见，见 [:arrow_down:](#关联数据)

# 信息描述的发展

然后还有一个跟我们专业相结合的，就是大家要知道，比方说在信息描述发展部分，我们之前讲了很多内容，就是把这个关联数据，它有一个重要的作用。特别是我们图书馆作为一个机构，它在关联数据方面怎样去应用，或者说它有什么样的优势，对吧？以及刚才我们讲的第三章的 FRBR，它在我们图书馆现在这个检索系统当中是怎样应用的，像这种，大家一定要有一个比较全面的认识。

参考 PPT，和教材第一章。

## 语义网络

一种可以被计算机理解的方式描述事物的网络

现代 Web 的扩展

良好的方式表示和连接

***

关联数据是语义网实现的必要部分（承上启下）

## 关联数据

关联数据是

- 一组最佳实践（best practice）的集合，
- 采用 RDF 数据模型，
- 利用 URI 命名数据实体，
- 发布和部署实例数据和类数据，
- 从而可以通过 HTTP 协议揭示并获取这些数据，
- 强调数据的相互关联、相互联系和有益于人机理解的语境信息。

特性

- 基于 URI 作为表示（即，类似于 DOI 的标识符）
- 使用 HTTP URI，可以访问（即，一个确定的网址）
- 以 RDF 提供可用信息（即，前面提到的 E-R 模型）
- 提供链接，指向其他 URI，构建网络（关联）

当你不理解关联数据的时候，你就想一下 Wikipedia。

### 地位

语义网堆栈（Semantic Web Stack、Semantic Web Layer Cake）描述了语义网技术的组织结构，由 Tim Berners-Lee 创建。

![image-20260103084202743](https://suxiaomin-tuil.oss-cn-wuhan-lr.aliyuncs.com/typora/20260104114541891.png)

大一信息管理学教材亦有此图。

关联数据是语义网实现的数据基础。为实现语义网的逻辑推理功能提供基础数据及数据之间的语义关联。

## 开放关联数据集 & 项目

### 特性

开放：类似于代码中的开源

关联：数据结构化，彼此有关联

数据集

### 项目背景

问题：语义网络建设需要

方案：将现有开放数据集转换成 RDF，建立关联

## 图书馆关联数据领域现状

参考PPT。

### 背景

1. 信息多（大量书目信息）
2. 关联密（RDF）
3. 利用率不高
4. 必须要提升信息服务能力

### 作用

1. 改善资源发现服务
2. 提高检索效率与资源整合效率
3. 提升资源发现服务
4. 聚合语义相关的信息资源，提高信息资源的丰富度。
5. 实现知识服务

### 行动

1. 发布图书馆关联数据集
2. 建立跨地区、跨领域的关联数据库
3. 提供服务

### 优势

1. 积累深厚（虽然缺乏利用）
2. 经验丰富
3. 天然联系（FRBR、RDA 的结构类似于关联数据）

### 案例

1. 美国国会图书馆书目数据、
2. 剑桥大学图书馆书目数据

## DOI

虽然看起来不是很重要的内容，但是，感觉还是很有价值的。毕竟，这也是我见过的为数不多的元数据了。

参见 [知乎](https://zhuanlan.zhihu.com/p/1911713915068482422)，论文需要DOI。一个很简单的用处就是防止AI编论文，因为论文的DOI是不能被伪造的。

Digital Object Identifier ，数字化对象标识符

给数字对象分配全球永久 & 唯一的标识符。

- DOI 编码
- DOI 解析技术
- DOI 数据模型
- DOI 系统实现

# 资源描述题

考试重点，参考 [第七章-DC 元数据 PPT-点击下载](https://suxiaomin-tuil.oss-cn-wuhan-lr.aliyuncs.com/typora/20260102092735733.pptx)，

资源描述题

1. 用 DC 元数据去描述，然后用 RDF XML 去做标注
2. 用 HTML 去做标注

这是我们资源描述题要求大家去掌握的。那么这一章的内容呢，大家可以在这个国家在线当中去找信息描述理论这门课。可以看一下 8.4，就是怎样使用 HTML 去做这个指标，反正第八章这个 PPT 大家可以重点去复习一下。 

编码体系修饰词，怎么使用 HTML 去做置标，它的语法的基本规则，包括我们怎么在这个命名域当中要放什么内容，对吧。还有我们之前一直讲的 **link 元素也是很重要的一个元素**，

同样在一个题当中，我要使用 DC 元数据。但是我们之前上课跟大家讲过，有的时候 DC 元数据它并不够用，或者是说它并不合适，我要可能使用一些专有领域的元数据去做描述的话，比方说这个地理信息的，那就是用 AGIS，还有这个。那么我怎么样在一个制定标准的时候，使用这些元数据和其他元数据去混合置标，那这个是一些参考例子，就是在我们这个例子当中给大家去做参考的。

比方说我最前面我的这个 link rel 里面是什么，对吧？ Link relation 里面分什么，它的语法基础是什么？它的语句法基础是什么？然后这个 metadata 后面是什么？跟的是什么对吧？还有这个 content 的后面是什么。特别是我们之前跟大家讲过对吧，

在用哪些语言去做置标的时候，可以不区分大小写，哪些语言去做置标的时候要区分大小写，对吧？

HTML，在这个部分当中，我们重点去要求大家写的，肯定就是只让他去写害的部分了，就大家只要去参考的，而且大家注意，就你们在写资源描述题的时候。在写资源描述题的时候，你们写的时候也要遵循我们这个结构，就是要有这样一个层级递进的结构。

XMR 对 DC 置标，包括里边我们之前上课的时候给大家讲过很多错误的例子，对吧？比方说怎么用 RDFS 去进行置标，那么包括这是一个比较全面的例子，然后呢，包括我们在这里怎么样去修饰词，包括如果说我们现在让你们做这个 RDF，比如用 RDF/XML 来做置标的话，你上面肯定是要有些基本的命名规则，对吧？还有包括它的基本句法，大家要对其有所掌握。

包括你们在写的时候，也需要采取这样递进的形式去写，大家注意你的起始标记、结束标记，一定要这个注意，像我们这里面很多用到一些案例。我们那几天用到的一些案例， 然后我们上课的时候。考这个资源描述的时候，我肯定不可能让大家就描述一本书，一个作者，对吧？这个太简单了，那十五分也太简单了，对吧？那我们肯定会重点去考大家：

1. 我们之前跟大家讲过有很多的元素修饰词，对吧？那么元素修饰词，哪些是对核心元素的修饰词，哪些是编码体系修饰词，编码体系修饰词怎么去表示，对吧？
2. 你比方说，我对这个网页的主题去描述，那我这个主题在描述的时候主题词表来源于编码，哪个编码体修饰词的，这个我肯定会给大家。但是呢，你像这些怎么去表示对吧，
3. 包括一些核心的 DC 元数据的核心元素，比方说创建者、日期对吧，
4. 我同样在描述日期的时候，我们之前一直跟大家讲日期也有编码体义修饰词对吧，它使用什么样的学习标准去描述这个日期，还有一些，比方说我们前一讲的媒体格式对吧，还有一些语言，那这些都是一些比较重要的内容。
5. 大家去掌握的句法，比方说我们之前讲过网络资源之间的资源之间的关系对吧？哪些是 pass 的关系？哪些是 repair 关系？这个关系怎么去表示，大家也要清楚
6. 区分出 XML 语言置标的时候和 HTML 语言置标的时候，它们语法之间的区别，大家到时候写的时候不要把两个写混淆了。



## 标记语言的价值

1. 结构清晰
   1. 如，XML 严格的嵌套格式
2. 易于理解
   1. XML 还是具备可读性的
3. 易于交互
   1. 纯文本，不需要进行复杂的转换
   2. 方便网络传输（如果不好理解的话，让我们阅读一下 Base64 编码的 image 吧）
4. 兼容性和平台独立性
   1. 不基于特定的系统
   2. 如，docx 可以被不同的软件解析（因为是用 XML 写的）
5. 方便将元数据与描述的对象整合在一起
   1. 如，metadata 可以方便嵌入 HTML 当中
   2. 如，docx 中也嵌入了自己的 core.xml
   3. 如 Markdown 的文件也可以使用 YAML 配置自己的元数据

上述优点独立于 DC。

## HTML 对 DC 置标

参见 [前文](#HTML 示例)，

```html
<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <!-- 声明 dcterms 命名空间 -->
    <link rel="schema.dcterms" href="http://purl.org/dc/terms/" />

    <!-- 标题（人类可读） -->
    <title>信息描述 - 吴丹 著</title>

    <!-- DCMI 元数据 -->
    <meta name="dcterms.title" content="信息描述" lang="zh" />
    <meta name="dcterms.creator" content="吴丹" lang="zh" />
    <meta name="dcterms.publisher" content="武汉大学出版社" lang="zh" />
    <meta name="dcterms.date" content="2022" scheme="DCTERMS.W3CDTF" />
    <meta name="dcterms.type" content="Text" scheme="DCTERMS.DCMIType" />
    <meta name="dcterms.format" content="application/pdf" scheme="DCTERMS.IMT" />
    <meta name="dcterms.language" content="zh" scheme="DCTERMS.RFC4646" />
    <meta name="dcterms.subject" content="信息组织" lang="zh" />
    <meta name="dcterms.subject" content="元数据" lang="zh" />
    <meta name="dcterms.subject" content="都柏林核心" lang="zh" />
    <meta name="dcterms.subject" content="编目" lang="zh" />
    <meta
      name="dcterms.description"
      content="本书系统介绍信息描述的基本理论、方法与应用，涵盖MARC、DC、RDA等主流元数据标准，适用于图书情报学专业教学与研究。"
      lang="zh"
    />
    <meta name="dcterms.identifier" content="ISBN:978-7-307-22450-6" />
    <meta name="dcterms.relation" content="武汉大学信息管理学院教材系列" />
    <meta name="dcterms.coverage" content="中国" lang="zh" />
    <meta name="dcterms.rights" content="© 武汉大学出版社 2022" lang="zh" />
    <!-- 若有开放许可，应优先用 dcterms.license + 官方URI -->
    <!-- <meta name="dcterms.license" content="https://creativecommons.org/licenses/by-nc-nd/4.0/"> -->

    <!-- 可选：兼容旧系统，提供 dc 前缀（不推荐新增项目使用） -->
    <!--
  <link rel="schema.dc" href="http://purl.org/dc/elements/1.1/">
  <meta name="dc.title" content="信息描述">
  <meta name="dc.creator" content="吴丹">
  <meta name="dc.publisher" content="武汉大学出版社">
  --></head>
  <body>
    <!-- 页面内容 -->
  </body>
</html>

```

值得一提的是，HTML 并不是用来给元数据置标的，所以，置标的效果一般。

### 方法和注意事项

✅ **基本结构**：  
使用 `<meta>` 标签提供元数据，格式为  

```html
<meta name="前缀.元素名"  scheme="" content="值" lang="语言代码（可选）">
```

例如：

```html
<meta name="dcterms.title" content="论文标题" lang="zh">  
<meta name="dc.date"      scheme="dcterms.W3CDTF"      content="2023-04-18">
<meta name="dcterms.title" content="论文标题" lang="zh">
<meta name ="DC.Relation.requires" scheme = " DCTERMS. URI"     content="http://www.foo.bar/stylesheet.css">
<meta name ="DC.Relation.isFormatOf"   scheme = " DCTERMS. URI"   content="http://www.foo.bar/explanation.doc">
<meta name ="DC.Relation.hasFormat"     scheme = " DCTERMS. URI"     content="http://www.foo.bar/explanation.pdf">
<meta name ="DC.Format.medium" scheme =" DCTERMS.IMT" content ="text/html">< meta name ="DC.Format.extent" content ="27kB" >
```

上述是一个使用日期 scheme 的案例。注意，HTML 不区分大小写，XML 只能使用小写，推荐都使用小写。

relation 见 [:arrow_up:](#Relation)

上述示例最好牢牢背下来。

✅ **必须配合 `<link>` 声明命名空间**：  
在 `<head>` 中先用 `<link>` 将本地前缀（如 `dc` 或 `dcterms`）绑定到官方 URI：  

```html
<link rel="schema.dcterms"href="http://purl.org/dc/terms/">
```

前缀可以自定义，而且 HTML 不区分大小写。

❌ **常见错误**：  

- 省略 `<link>` 声明却直接用 `dc.title`（解析器无法识别语义）；  
- 弄混 scheme 和 schema（正是在下），scheme 是编码体系，如日期的编码体系，schema 是词汇表，schema 在 XML 中表示结构，感觉不是考点，但是，还是尽可能弄清楚吧。参见 [千问](https://www.qianwen.com/share?shareId=ede85e9a-3e14-469a-b7d1-9b2ab1df4858)

---

### `<link>` 的核心作用

✅ **声明命名空间前缀**：  
`<link rel="schema.X" href="URI">` 的作用是：  

> “此后所有 `name="X.xxx"` 中的 `X`，代表该 URI 所定义的词汇表。”

✅ **实现全局唯一语义标识**：  
`dcterms.title` 实际等价于完整 URI `http://purl.org/dc/terms/title`，确保不同系统对“title”的理解一致。

⚠️ **URI 不是链接，而是身份标识**：  
即使 `href` 指向一个不存在的页面（如 `http://example.com/fake`），HTML 不会报错，但元数据将失去互操作性——因为语义身份被伪造了。

✅ **给 URI 置标**： 

当一个属性值是另外一个资源的 URI 的时候，可以使用 link 方式，虽然，这种方式并不是规范，同时也已经过时。

形如

```xml
<link rel="dc.relation" href="http://www.example.org/">
```

其实在效果上和 metadata 的写法是等价的，但是，教材认为，这样就更好地表示了和实体的关联。

---

### `dc` 与 `dcterms` 的区别

✅ **来源不同**：  

- `dc`：1999 年原始“都柏林核心 15 元素”，非形式化，仅文本标签；  
- `dcterms`：2008 年后 DCMI 术语集，基于 RDF 正式定义。

✅ **语义严谨性**：  

- `dcterms.title` 是一个 **RDF 属性（rdf: Property）**，有明确的域（domain）、范围（range）、是否允许多值等机器可读语义；  
- `dc.title` 只是一个字符串字段，无法参与推理或与其他数据集安全互联。

✅ **功能更全**：  
`dcterms` 包含更多属性（如 `license`、`created`、`modified`），而 `dc` 仅有 15 个宽泛元素。

✅ **现代标准推荐**：  
DCMI 官方、Schema.org、图书馆/档案馆系统均优先采用 `dcterms`。  
例如：表达许可证应使用  

```html
<meta name="dcterms.license" content="https://creativecommons.org/licenses/by/4.0/">
```

（`dc` 甚至没有 `license` 属性！）

📌 **一句话总结**：  

> `dc` 是“能用”，`dcterms` 是“能被机器真正理解”。在语义网时代，后者才是负责任的数据实践。



### 五个递进问题（和考试没有关系）

1. 如果我只写 `<meta name="title" content="Test">`，这算 DC 元数据吗？为什么？
2. 能否同时使用 `dc.title` 和 `dcterms.title` 描述同一资源？如果能，是否冗余？是否推荐？
3. `<link rel="schema.dc" href="http://example.com/fake">` 这样写会怎样？解析器会报错吗？
4. 为什么 DC 官方推荐优先使用 `dcterms` 而不是 `dc`？这和 RDF 有什么关系？
5. 如果我想表达“本文受 CC BY 4.0 许可”，应该用哪个 DC 属性？写出完整的 HTML 元标签。

可以自己问 AI，加深对于 HTML 置标的理解。

## XML 给 DC 置标

参见前文 [core.xml](#core.xml)，

主要的做法也只是，

申明命名域，这里是 dc 的命名域和 dcterms 的命名域

使用对应的命名域作为标签，构建元素，字符串值就是元素的内容。

```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<cp:coreProperties
    xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties"
    xmlns:dc="http://purl.org/dc/elements/1.1/" 
    xmlns:dcterms="http://purl.org/dc/terms/"
    xmlns:dcmitype="http://purl.org/dc/dcmitype/"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <dcterms:created xsi:type="dcterms:W3CDTF">2023-01-12T04:50:00Z</dcterms:created>
    <dc:creator>Liang Shaobo</dc:creator>
    <cp:lastModifiedBy>Su Xiaomin</cp:lastModifiedBy>
    <dcterms:modified xsi:type="dcterms:W3CDTF">2025-12-14T03:57:05Z</dcterms:modified>
    <cp:revision>13</cp:revision>
</cp:coreProperties>
```

需要注意的是

1. 元数据的命名域全部都是小写的

   1. 即，只有 dcterms: created ，但是没有 Dcterms: created
   2. 不是语法限定，而是习惯。因为命名域前缀是可以自定义的。换言之，使用Dct当做dcterms的前缀也完全不影响，只要如此申明即可。但是最好还是按照约定俗成的写法。
2. 可以按需重复

3. 可以使用 `<dc:subject xml:lang="en">seafood</dc:subject>` 如此方式来申明语言。

4. 可以使用 `<dcterms:created xsi:type="dcterms:W3CDTF">2023-01-12T04:50:00Z</dcterms:created>` 的方式来申明编码体系。注意，`xsi`也需要事先申明。
5. 优先使用 dcterms 进行置标。即使存在对应的 dc 元素。


## RDF/XML 给 DC 置标

参考 [XML 给 DC 置标](#XML给DC置标)，需要注意的是，这里需要申明 RDF 的命名域

```xml
<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
         xmlns:dc="path"
         "......">
```

自行申明需要的命名域。

RDF 是根元素。

下面的所有元素都是 Description，使用 rdf: Descritption 的方式申明就可以了，使用 rdf: about = identifier 的方式再申明一下资源的定位符，一般都是一个 URI，如 URL 或者 URN 乃至 DOI、ISBN。

参见 [千问](https://www.qianwen.com/share?shareId=347b4a4e-482d-4b9c-bc78-3734b98d52bc)。



请你提供使用 RDF/XML 对于 DC 进行置标的范例，同时补充注意事项，如 DC 修饰词名域 vcard 格式等

以下是一个使用 **RDF/XML** 对 **都柏林核心（Dublin Core, DC）元数据** 进行置标的完整范例，并附带关于 **DC 修饰词（Qualified Dublin Core）命名空间**、**vCard 格式** 以及相关注意事项的说明。

---

### 一、RDF/XML 中使用 DC 的基本范例

```xml
<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
  xmlns:dcterms="http://purl.org/dc/terms/"
  xmlns:dcam="http://purl.org/dc/dcam/"
  xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#">

  <!-- 定义资源：该书 -->
  <rdf:Description rdf:about="urn:isbn:978-7-307-22450-6">
    <!-- 标题 -->
    <dcterms:title xml:lang="zh">信息描述</dcterms:title>

    <!-- 作者 -->
    <dcterms:creator xml:lang="zh">吴丹</dcterms:creator>

    <!-- 出版社 -->
    <dcterms:publisher xml:lang="zh">武汉大学出版社</dcterms:publisher>

    <!-- 出版日期（年份） -->
    <dcterms:date>2022</dcterms:date>

    <!-- 资源类型（DCMI Type Vocabulary） -->
    <dcterms:type rdf:resource="http://purl.org/dc/dcmitype/Text"/>

    <!-- 文件格式（MIME 类型） -->
    <dcterms:format rdf:resource="http://www.iana.org/assignments/media-types/application/pdf"/>

    <!-- 语言（BCP 47 / RFC 4646） -->
    <dcterms:language>zh</dcterms:language>

    <!-- 主题词（多个） -->
    <dcterms:subject xml:lang="zh">信息组织</dcterms:subject>
    <dcterms:subject xml:lang="zh">元数据</dcterms:subject>
    <dcterms:subject xml:lang="zh">都柏林核心</dcterms:subject>
    <dcterms:subject xml:lang="zh">编目</dcterms:subject>

    <!-- 描述 -->
    <dcterms:description xml:lang="zh">本书系统介绍信息描述的基本理论、方法与应用，涵盖MARC、DC、RDA等主流元数据标准，适用于图书情报学专业教学与研究。</dcterms:description>

    <!-- 唯一标识符（ISBN） -->
    <dcterms:identifier>ISBN:978-7-307-22450-6</dcterms:identifier>

    <!-- 关系（所属系列） -->
    <dcterms:relation>武汉大学信息管理学院教材系列</dcterms:relation>

    <!-- 覆盖范围（地理） -->
    <dcterms:coverage xml:lang="zh">中国</dcterms:coverage>

    <!-- 版权声明 -->
    <dcterms:rights xml:lang="zh">© 武汉大学出版社 2022</dcterms:rights>

    <!-- 可选：许可证（如使用 CC BY-NC-ND 4.0） -->
    <!--
    <dcterms:license rdf:resource="https://creativecommons.org/licenses/by-nc-nd/4.0/"/>
    -->
  </rdf:Description>
</rdf:RDF>
```

---

### 二、关键注意事项

#### 1. **命名空间（Namespace）**

- **`dc:`**：对应 **Dublin Core 元素集 1.1**（未限定版本），URI 为 `http://purl.org/dc/elements/1.1/`。
- **`dcterms:`**：对应 **DCMI Metadata Terms**（即“限定版”或“修饰词”版本），URI 为 `http://purl.org/dc/terms/`。
  - 推荐优先使用 `dcterms:`，因为其属性具有明确定义的语义（如范围、域、数据类型等），更适合 RDF 应用。
  - 例如：`dcterms:creator` 的值应为一个资源（如 vCard 实体），而 `dc:creator` 的值通常为字符串。

- `xmlns:rdf`: RDF 语法基础。
- `xmlns:rdfs`: RDF Schema（可选，用于更复杂的语义建模）。



#### 2. **DC 修饰词（Qualified Dublin Core）**

- DC 修饰词是对基本 DC 元素的细化，如：
  - `dcterms:created`, `dcterms:modified`, `dcterms:issued`（细化 `dc:date`）
  - `dcterms:spatial`, `dcterms:temporal`
- 使用修饰词时，**务必声明 `dcterms` 命名空间**，并注意其 RDF 属性类型（object 可能是字面量或资源）。
- XML 中严格区分大小写
- DC 的命名域前缀词与元素名采用全部小写的格式
- rdf 的 Description 属性的开头是大写，和 dc: dcription 区分。

#### 4. **数据类型（Datatype）标注**

- 对于日期、数字等，应使用 `rdf:datatype` 明确类型，例如：

  ```xml
  <dcterms:issued rdf:datatype="http://www.w3.org/2001/XMLSchema#date">2025-03-15</dcterms:issued>
  ```

- 否则默认为字符串，影响语义推理和查询。

#### 5. **避免混用 dc 与 dcterms**

- 虽然技术上可以混用，但为保持一致性与互操作性，**建议统一使用 `dcterms`**。
- 例如：不要同时用 `dc:creator`（字符串）和 `dcterms:creator`（资源）描述同一实体。

#### 6. **资源 vs 字面量**

- `dc:creator` 通常为字面量（如 "张三"）
- `dcterms:creator` 应指向一个资源（如 vCard 实体或 foaf: Person）
- 在 RDF 图中，这会影响三元组的结构和后续处理。

#### 7. **资源标识（`rdf:about`）**

- 使用 `urn:isbn:978-7-307-22450-6` 作为资源 URI 是一种常见做法。
- 也可以使用 HTTP URI（如出版社提供的图书页面 URL），但 ISBN URN 更通用且持久。

---

### 三、参考命名空间汇总

| 前缀      | URI                                           |
| --------- | --------------------------------------------- |
| `rdf`     | `http://www.w3.org/1999/02/22-rdf-syntax-ns#` |
| `dc`      | `http://purl.org/dc/elements/1.1/`            |
| `dcterms` | `http://purl.org/dc/terms/`                   |
| `vcard`   | `http://www.w3.org/2006/vcard/ns#`            |
| `xsd`     | `http://www.w3.org/2001/XMLSchema#`           |

---

教材中提到了 dcq，但是我没有检索到相关的内容，结合 [DeepSeek](https://chat.deepseek.com/share/6bx3hdlbvexpnfij0n)，可以大概确认，这个东西只是一个过渡方案，教材可能直接把过渡方案定义成了永恒。一般来说，直接使用 dcterms 就好，乃至可以使用 dc 的时候。

### PPT 示例



![image-20260103115737617](https://suxiaomin-tuil.oss-cn-wuhan-lr.aliyuncs.com/typora/20260104114608329.png)

对比一下就不难发现，PPT 的示例更喜欢使用 dc 而非 dcterms。

# 其他

## 信息描述

应该怎么看这门课呢？

信息描述，一言以蔽之，曰：元数据。再一言，曰：关联数据。

实际上，这门课也有一点割裂吧，像是 MARC，我高低得觉得它有点过时，但是比起来目录学教授的内容，又感觉，还行。至于说 XML，也是上了这门课（可能自学还居多一点，也可能是，我确实有一点笨，上课听不懂，下课花功夫），才深入了解，之前只是知道，很多编程框架都使用 XML 作为配置文件。

MARC 是建立元数据的一种方式，虽然当时设计 MARC 的时候未必想到有一天要基于它的扩展来建立关联数据。

FRBR 是一套世界观，基于实体的关联，它已经像是要建立关联数据了。信息描述走向关联数据是很自然的过程。

RDA 是一种细化的原则，当然，它也是 MARC 的泛化。 

RDF 则也细化到了框架，操作性比 RDA 还要强。

XML 是置标语言，可以方便进行元数据的陈述。可以方便扩展语法。它比自然语言强大的地方就在于，它有着严格的机器可以理解的结构。

RDF/XML 则只是，基于 RDF 的理念，使用 XML 陈述。表达的方式。就好像主谓宾，汉语可以说，英语也可以说。RDF/XML 也可以无损翻译成 RDF/Turtle。为什么没有 RDF/HTML，因为 HTML 志不在此，如果我提一点建议，就是，我们不需要在这一门课上学习基于 HTML 来撰写元数据，我们可以再学习 RDF/Turtle。或者，我们学习一下 [RDFa](https://www.qianwen.com/share?shareId=40efed58-23a1-4529-8a6f-05363ef716f5) 的理念，即，无损地添加一些机器可以阅读理解的内容，虽然这些内容对于人类是不可见的。

DC 是一套不断发展的通用元数据标准。dcterms 是一套非常丰富的范畴，而且也是 RDF 化的。

其他的命名域也可以方便嵌入 XML 中，当然，也可以方便嵌入 RDF/XML 当中。

为什么说一个 书评 不是对于书的信息描述呢？至少，它不是完整的信息描述。因为，它是自然语言，而不是结构化的。所以，可用性并不是很高。

就好像说我们的信息计量吧，你不能真的去读一篇论文，接着点评它好或者坏，你要计量，那可能就是几万篇文献了，如果一篇篇读，做评价，再计量，并不现实。

所有的信息资源基于同样或者可以兼容的命名域的元数据描述之后，就可以自然彼此关联，也就构建了语义网络。

为什么超链接和超文本不是上述层面的语义网络呢？因为超链接不是结构化的，它只不过在一处有一个指针，指向另外一处，可能还在本资源，也可能跳转到另外一个网页了，但是，这个指针是没有结构语义的。如果这种超链接可以建立结构语义，同时是规范的，基于一套元数据标准，那么，也可以说，超链接就能够建立语义网络了。但是，强行使用超链接实现这种功能，总归不如 XML 清晰和规范。

## 回顾

会有人把这一份水水的复习笔记读完吗？或者，直接跳到结尾，看一下私货。

做笔记的时候，是一天一章，但是，我几乎是无状态的，今天做了什么东西，明天不太会记得。

比较好的做法是，每一天都回顾一下之前做过的内容，如果教材中某一个知识点反复出现，那么它第二次出现的时候，只需要在第一次出现的地方追加就可以了，很遗憾，我做完整理笔记的时候才意识到这一点，就好像 MARC、RDA、RDF、DC、关联数据，在笔记里面都出现了很多次。

无所谓了，我自己还是知道详略得到的，只不过整体上，结构确实不太好。而且有诸多不合时宜的表述，没关系，就让后来者忍受吧。

也是，做笔记的过程本身其实就是重新学习一次 **信息描述** 。

如果可以重新学习的话，我会怎么做呢？大概，我不会拖延到期末考试才开始看书，大概，我会大概随着上课的进度来，跳过那些纯粹死记硬背的地方，慢慢做笔记，早一点把 PPT 都通读一遍。我不知道。

最后，我也有一点想要阐述的内容

## 文件格式

文件格式也是很古老的一个问题。

自己想要把 Word 转成 Markdown，使用 pandoc。

但是，图片在哪里？

偶尔，使用合适的参数，可以蹦出来一个 media 的文件夹，里面的图片按照序号进行命名。

为什么，为什么 docx 可以转换得到这样一个文件夹呢？

好奇之下，就去询问。

于是，也就知道了，原来，docx 的 x 不是某种 super 的美式表达，而是说，它基于 XML。

伟大的 XML。

也探讨了关于 Markdown 的问题。

起源于 ChatGPT 的那个 [提问](https://suxiaomin-tuil.oss-cn-wuhan-lr.aliyuncs.com/typora/20260103130108420.html)

如果你想用 Markdown 写论文，还需要扩展怎样的语义？

我自己确确实实是在实践使用 Markdown 写论文，我没有感觉什么不方便的，所以，我感觉不需要扩展。

## 范畴

其实，还是需要的。这里就涉及到了内容结构

我们来区分三个概念，我自己定义的三个概念

内容：换言之，也就是字符面的字面量，比如说，“摘要”，这两个字，放在论文的开头，即使你不看它特立独行的格式，你也知道，它后面跟着的是论文的摘要部分。换言之，内容语义也就是把论文直接变成 txt 文本之后，还剩下的东西。（不附带置标语言）

内容结构：就比如说，一级标题，二级标题，引用，摘要，表格，列表，等等，它们都是对于内容进行的组织。Word 可以组织，即基于 XML，HTML 可以组织，自己有一套繁琐的语法，Markdown 可以组织，LaTeX 也可以组织，只不过各自的能力和代价不同，适用的场景不同。

资源结构：即，这个资源和其他资源实体的关系是什么？

资源结构也可以分为资源的属性和实体之间的关系，参见 RDA。在我定义的范畴下，资源结构其实就是资源的元数据的一部分。也即，元数据中可以用在建立关联数据的那部分。

内容结构其实也可以用来建立关联数据，但是说到底，为了清晰的结构，资源必须要拆分，我们不能把所有的内容都写在一个资源当中，再通过内容结构进行组织。

不过，Markdown 只能组织内容结构，换言之，它只能去申明，这里是一级标题，并且蕴含这样的语义，一级标题下面的所有内容，包括二级标题都属于一级标题，想要组织资源结构，它就只能依靠 YAML 了。而 Word 组织这个东西也比较费力，毕竟 Word 是用来打印的。LaTeX 的支持要稍微好一点，XML 原生支持的，Turtle 更是被设计出来干这事的。像是 HTML，我并不认为它适合做这种事情，我感觉 HTML 组织资源结构就好像 Markdown 一样，都是在努力做自己不适合做的事情。

信息描述讨论的更多是资源的元数据，只不过，我日常中更多考虑的是某个资源具体的内容，再加上它的内容结构，二者之间存在一道鸿沟

## 论文

为什么 Markdown（原始的）其实不太适合写论文。

因为，Markdown 的内容结构是残缺的，没有资源结构。因为，它和 HTML 一样，天然只是为了渲染，为了呈现。

我可以使用 Markdown 做出来一份很好看的笔记，呈现非常多的内容语义，加上代码高亮，加上基于各种语法的结构渲染，让它对于人类来说具备相当的可读性，然而，它依旧是残缺的。

我无法用 Markdown 表示 **摘要**，我总不能在 Markdown 中写 `<restract>摘要</restract>` 的结构，多少有一点像小丑。当然，既然一切都是渲染，挑选一个支持这样渲染的主题，也未尝不可，但是，这样似乎我们就已经在走向 LaTeX 乃至 XML 了。原生的 Markdown 其实压根就没有 HTML 的语法，只不过，因为这样的 Markdown 太多的限制，所以，就出现了各种扩展，像是我使用的 Typora，在扩展上就已经是集大成了。再搭配几个插件……

这也是，为什么 Word 适合写论文。它适合写的原因

并非

1. 好看。（显然并不，Word 超丑的，不能理解做笔记的时候还拿 Word 的理由）
2. 支持格式调节（显然，你既然基于 XML 和 CSS，那我 Typora 用 HTML+CSS 也行）

而是

1. 支持复杂的样式表
2. 为打印而做的一些设计，比如说分页符

样式还需要自定义，自己新建的 Word 一般只有基础的样式，不比原生的 Markdown 复杂。难怪说，写论文需要一个模版。如果大家基于同样的模版，模版会提供各种的样式，这样的样式表就可以类比成 Schema，XML 的命名域，于是，就有了相互理解的基础。

记得当时写信息行为的论文的时候，梁老师也提供了一个模版，然而，他只是说，

正文内容，中文字体宋体小四，英文字体 Times 小四。全文行距 1.25 倍。

使用本文档格式，可以直接将草稿文本内容，合并格式粘贴过来，标题的格式使用格式刷，统一调整。

这样多少感觉有一点无聊了。

所以，这也是 LaTeX 的伟大的地方了，更高级的排版语言。直接申明复杂的内容结构，接着调用引擎去排版就可以了。

倘若，倘若我们放弃对于复杂内容结构的需要，我们仅仅需要样式，乃至可以接受使用字体和大小模仿样式，那么，Markdown 就非常适合写论文了。

实际上，算上扩展的语法，Markdown 也很适合写论文了。只不过，Markdown 扩展的语法全部都是用来渲染的。

就比如说，它支持 LaTeX 的扩展语法。

```md
$$
e^{i\pi}=-1
$$
```


$$
e^{i\pi}=-1
$$
来渲染一个数学公式，虽然是为了渲染，但是效果上也等同于申明，这里是一个数学公式。

它也支持申明引用，申明代码块，乃至细节到哪一种代码，这是为了高亮而设置的细分，
````md
``` python
def render(markdown):
    if node_list = check(markdown):
        results = []
        for node in node_list:
            results.add(node)
        return results
    return null
```
````

如下的基础高亮，前面的 XML 的渲染也看得多了。

```python
def render(markdown):
    if node_list = check(markdown):
        results = []
        for node in node_list:
            results.add(node)
        return results
    return null
```

但是，同时，它也自然承担了足够的语义，这一点，它甚至比 Word 要方便得多。你只需要写就可以了，语义和渲染，都由解析器来承担。

选择一个好看的 CSS 主题，撰写一个简单的 Markdown 文件，之后导出成 PDF 就可以。

或者，选择一个合适的 template.docx，接着使用 pandoc 导出成 docx 就可以了。

当然，直接使用 Word 写论文也未必多么麻烦。

## 信息描述的价值

聊到这里，差不多也就可以开始讨论信息描述的价值。只不过，其实，或许，我想聊的内容已经不是信息描述了，但是它碰巧出现在这本书上面。

为什么我们需要更复杂的内容结构，那些 Markdown 的原生语法不能支持的内容结构？如果我可以使用一级标题或者二级标题乃至直接写原生的 <span style="font-size:2em;">HTML</span> 伪造出来出来摘要的效果，为什么，为什么这样的 Markdown 还是不能作为论文呢？因为，那只是视觉效果。这样的论文，大概只能用来打印，也无法支持机器自动提取结构。

同样的道理，也可以用来解释，为什么我们需要元数据，需要 RDF，需要 RDFa。实际上，写在 HTML 中的 metadata，或者写在 Markdown 开头的 YAML，对于人类来说是不可读的，但是，它方便机器的提取。可以用来构建语义网络。参见 [千问](https://www.qianwen.com/share?shareId=eb2a904f-3c5f-40b9-b7e2-d72f721e7dd3) 。所谓元数据，其实应该放在信息组织里面，信息描述大概只是信息组织的一种实践，但是，我们大一的时候就学习到的信息组织……我不记得当时上了什么，可能上了 RDF，好像还有 HTML，乃至倒排索引，等等，只不过那时候我的能力不够。

人类天然偏好视觉的存在，传统的计算机则几乎只能处理结构化数据，更深刻的信息也只能从结构化信息中挖掘出来，所以，这就是信息描述的价值。

## 调整

如果你还想要修改这一份笔记，原始的 Markdown 文件，[点击](https://suxiaomin-tuil.oss-cn-wuhan-lr.aliyuncs.com/note/InformationDescription.md) 下载。

点击的东西也是一个 URL，当然，也就是这一份资源的 URI，虽然点击就是下载，但是，下载的资源和原始资源显然已经不是一个资源了。电子资源具有可复制性，但是一个 URI 对应的就是一个资源的实体，换言之，这里我存储这一份 URI 对应的就是这个 Markdown 实体，虽然它反复在动。

我是有一点厌烦了。因为每一个都需要同时维护两个文件，一个是原始的 Markdown 文件，另外一个则是构建的 HTML 网页，想着修改了一个，最好把另外一个也修改一下，因为这个 URI 是我手动把本地的资源上传的结构，多少有一点麻烦。

所以，之后这样的事情我是懒得做了。大概，随便找一个……还是好麻烦。反正有 HTML，自己复制粘贴也挺方便的。

##  打赏

随缘……

<img src="https://suxiaomin-tuil.oss-cn-wuhan-lr.aliyuncs.com/typora/20260104185318731.png" alt="mm_reward_qrcode_1767523868497" style="zoom:25%;" />