<!doctype html><html lang="zh-CN"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="generator" content="VuePress 2.0.0-rc.26" /><meta name="theme" content="VuePress Theme Plume 1.0.0-rc.185" /><script id="check-mac-os">document.documentElement.classList.toggle('mac', /Mac|iPhone|iPod|iPad/i.test(navigator.platform))</script><script id="check-dark-mode">;(function () {const um= localStorage.getItem('vuepress-theme-appearance') || 'auto';const sm = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;const isDark = um === 'dark' || (um !== 'light' && sm);document.documentElement.dataset.theme = isDark ? 'dark' : 'light';})();</script><link rel="icon" type="image/png" href="https://theme-plume.vuejs.press/favicon-32x32.png"><title>轮询与回调 | My Vuepress plume</title><meta name="description" content="我的笔记和博客网站"><link rel="preload" href="/assets/style-taCD67sN.css" as="style"><link rel="stylesheet" href="/assets/style-taCD67sN.css"><link rel="modulepreload" href="/assets/app-B9c7vheQ.js"><link rel="modulepreload" href="/assets/index.html-DH1FI450.js"></head><body><div id="app"><!--[--><!--[--><div class="theme-plume vp-layout" vp-container data-v-3a454f83><!--[--><!--[--><!--]--><!--[--><span tabindex="-1" data-v-f78d71c4></span><a href="#VPContent" class="vp-skip-link visually-hidden" data-v-f78d71c4> Skip to content </a><!--]--><!----><header class="vp-nav" data-v-3a454f83 data-v-cb3e98d3><div class="vp-navbar" vp-navbar data-v-cb3e98d3 data-v-680a672f><div class="wrapper" data-v-680a672f><div class="container" data-v-680a672f><div class="title" data-v-680a672f><div class="vp-navbar-title" data-v-680a672f data-v-ed94bc63><a class="vp-link link no-icon title" href="/" data-v-ed94bc63><!--[--><!--[--><!--]--><!--[--><!--[--><!--[--><img class="vp-image dark logo" style="" src="https://theme-plume.vuejs.press/plume.png" alt data-v-ae126e27><!--]--><!--[--><img class="vp-image light logo" style="" src="https://theme-plume.vuejs.press/plume.png" alt data-v-ae126e27><!--]--><!--]--><!--]--><span data-v-ed94bc63>My Vuepress plume</span><!--[--><!--]--><!--]--></a></div></div><div class="content" data-v-680a672f><div class="content-body" data-v-680a672f><!--[--><!--]--><div class="vp-navbar-search search" data-v-680a672f><div class="search-wrapper" data-v-aa07b763><!----><div id="local-search" data-v-aa07b763><button type="button" class="mini-search mini-search-button" aria-label="搜索文档" data-v-aa07b763><span class="mini-search-button-container"><span class="mini-search-search-icon vpi-mini-search" aria-label="search icon"></span><span class="mini-search-button-placeholder">搜索文档</span></span><span class="mini-search-button-keys"><kbd class="mini-search-button-key"></kbd><kbd class="mini-search-button-key">K</kbd></span></button></div></div></div><!--[--><!--]--><nav aria-labelledby="main-nav-aria-label" class="vp-navbar-menu menu" data-v-680a672f data-v-d6a70cbc><span id="main-nav-aria-label" class="visually-hidden" data-v-d6a70cbc>Main Navigation</span><!--[--><!--[--><a class="vp-link link navbar-menu-link" href="/" tabindex="0" data-v-d6a70cbc data-v-0766e81b><!--[--><!----><span data-v-0766e81b>首页</span><!----><!--]--></a><!--]--><!--[--><a class="vp-link link navbar-menu-link" href="/blog/" tabindex="0" data-v-d6a70cbc data-v-0766e81b><!--[--><!----><span data-v-0766e81b>博客</span><!----><!--]--></a><!--]--><!--[--><a class="vp-link link navbar-menu-link" href="/blog/tags/" tabindex="0" data-v-d6a70cbc data-v-0766e81b><!--[--><!----><span data-v-0766e81b>标签</span><!----><!--]--></a><!--]--><!--[--><a class="vp-link link navbar-menu-link" href="/blog/archives/" tabindex="0" data-v-d6a70cbc data-v-0766e81b><!--[--><!----><span data-v-0766e81b>归档</span><!----><!--]--></a><!--]--><!--[--><div class="vp-flyout vp-navbar-menu-group" data-v-d6a70cbc data-v-6997242d><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-6997242d><span class="text" data-v-6997242d><!----><!----><span data-v-6997242d>笔记</span><!----><span class="vpi-chevron-down text-icon" data-v-6997242d></span></span></button><div class="menu" data-v-6997242d><div class="vp-menu" data-v-6997242d data-v-0b3e3d72><div class="items" data-v-0b3e3d72><!--[--><!--[--><div class="vp-menu-link" data-v-0b3e3d72 data-v-e1be3858><a class="vp-link link" href="/demo/" data-v-e1be3858><!--[--><!----> 示例 <!----><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--]--></nav><!--[--><!--]--><!----><div class="vp-navbar-appearance appearance" data-v-680a672f data-v-748f1e50><button class="vp-switch vp-switch-appearance" type="button" role="switch" title aria-checked="false" data-v-748f1e50 data-v-5d382c85 data-v-acb3e2b8><span class="check" data-v-acb3e2b8><span class="icon" data-v-acb3e2b8><!--[--><span class="vpi-sun sun" data-v-5d382c85></span><span class="vpi-moon moon" data-v-5d382c85></span><!--]--></span></span></button></div><div class="vp-social-links vp-navbar-social-links social-links" data-v-680a672f data-v-211d3e89 data-v-0e74c1cc><!--[--><a class="vp-social-link no-icon" href="/" aria-label="github" title="github" target="_blank" rel="noopener" data-v-0e74c1cc data-v-7e1a06d1><!----></a><!--]--></div><div class="vp-flyout vp-navbar-extra extra" data-v-680a672f data-v-e145a5fb data-v-6997242d><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-6997242d><span class="vpi-more-horizontal icon" data-v-6997242d></span></button><div class="menu" data-v-6997242d><div class="vp-menu" data-v-6997242d data-v-0b3e3d72><!----><!--[--><!--[--><!----><div class="group" data-v-e145a5fb><div class="item appearance" data-v-e145a5fb><p class="label" data-v-e145a5fb>外观</p><div class="appearance-action" data-v-e145a5fb><button class="vp-switch vp-switch-appearance" type="button" role="switch" title aria-checked="false" data-v-e145a5fb data-v-5d382c85 data-v-acb3e2b8><span class="check" data-v-acb3e2b8><span class="icon" data-v-acb3e2b8><!--[--><span class="vpi-sun sun" data-v-5d382c85></span><span class="vpi-moon moon" data-v-5d382c85></span><!--]--></span></span></button></div></div></div><div class="group" data-v-e145a5fb><div class="item social-links" data-v-e145a5fb><div class="vp-social-links social-links-list" data-v-e145a5fb data-v-0e74c1cc><!--[--><a class="vp-social-link no-icon" href="/" aria-label="github" title="github" target="_blank" rel="noopener" data-v-0e74c1cc data-v-7e1a06d1><!----></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="vp-navbar-hamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="nav-screen" data-v-680a672f data-v-85607bb2><span class="container" data-v-85607bb2><span class="top" data-v-85607bb2></span><span class="middle" data-v-85607bb2></span><span class="bottom" data-v-85607bb2></span></span></button></div></div></div></div><div class="divider" data-v-680a672f><div class="divider-line" data-v-680a672f></div></div></div><!----></header><!----><!----><!--[--><div id="VPContent" vp-content class="vp-content" data-v-3a454f83 data-v-44731843><div class="vp-doc-container is-posts" data-v-44731843 data-v-155f52e8><!--[--><!--]--><div class="container" data-v-155f52e8><!----><div class="content" data-v-155f52e8><div class="content-container" data-v-155f52e8><!--[--><!--]--><main class="main" data-v-155f52e8><nav class="vp-breadcrumb" data-v-155f52e8 data-v-6f17f8c4><ol vocab="https://schema.org/" typeof="BreadcrumbList" data-v-6f17f8c4><!--[--><li property="itemListElement" typeof="ListItem" data-v-6f17f8c4><a class="vp-link link no-icon breadcrumb" href="/" property="item" typeof="WebPage" data-v-6f17f8c4><!--[-->首页<!--]--></a><span class="vpi-chevron-right" data-v-6f17f8c4></span><meta property="name" content="首页" data-v-6f17f8c4><meta property="position" content="1" data-v-6f17f8c4></li><li property="itemListElement" typeof="ListItem" data-v-6f17f8c4><a class="vp-link link no-icon breadcrumb" href="/blog/" property="item" typeof="WebPage" data-v-6f17f8c4><!--[-->Blog<!--]--></a><span class="vpi-chevron-right" data-v-6f17f8c4></span><meta property="name" content="Blog" data-v-6f17f8c4><meta property="position" content="2" data-v-6f17f8c4></li><li property="itemListElement" typeof="ListItem" data-v-6f17f8c4><a class="vp-link link no-icon breadcrumb" href="/blog/categories/?id=5ebeb6" property="item" typeof="WebPage" data-v-6f17f8c4><!--[-->preview<!--]--></a><span class="vpi-chevron-right" data-v-6f17f8c4></span><meta property="name" content="preview" data-v-6f17f8c4><meta property="position" content="3" data-v-6f17f8c4></li><li property="itemListElement" typeof="ListItem" data-v-6f17f8c4><a class="vp-link link no-icon breadcrumb current" href="/blog/jlisg2zx/" property="item" typeof="WebPage" data-v-6f17f8c4><!--[-->轮询与回调<!--]--></a><!----><meta property="name" content="轮询与回调" data-v-6f17f8c4><meta property="position" content="4" data-v-6f17f8c4></li><!--]--></ol></nav><!--[--><!--]--><!--[--><div class="vp-doc-title" data-v-7f3915a0><!--[--><!--]--><h1 class="page-title" data-v-7f3915a0><!----> 轮询与回调 <!----></h1><!--[--><!--]--></div><div class="vp-doc-meta" data-v-7f3915a0><!--[--><!--]--><p class="reading-time" data-v-7f3915a0><span class="vpi-books icon" data-v-7f3915a0></span><span data-v-7f3915a0>约 3427 字</span><span data-v-7f3915a0>大约 11 分钟</span></p><!----><!--[--><!--]--><p class="create-time" data-v-7f3915a0><span class="vpi-clock icon" data-v-7f3915a0></span><span data-v-7f3915a0>2026-01-02</span></p></div><!--]--><!--[--><!--]--><!--[--><div class="_blog_jlisg2zx_ external-link-icon-enabled vp-doc plume-content" vp-content data-v-155f52e8><!--[--><!--]--><div data-v-155f52e8><p>请你扮演一个深刻、尖锐、语言犀利的老师，仔细阅读我的表述，捕获我的误解和狡辩，回答我的提问，同时给出学习的建议。请你回答的使用不使用Markdown的一级标题，而使用它的二级标题及以下的标题。</p><p>知识点：轮询与回调机制</p><p>我已知：</p><p>轮询和回调都可以避免长连接的建立，实现异步交互。</p><p>轮训的机制是，先提交任务，定期去检测，看一下任务的状态，任务完成就进入下一步。如果是对话，那么就是定期检测，看一下是否出现新对话</p><p>回调，则是提交任务之后，暴露一个端口，让对方调用这个端口，通知自己，换言之，类似于事件驱动架构。这样就不需要监听的损耗。尤其是那种长时间等待的任务，可以在任务完成后立刻接到通知。</p><p>我不懂：两种实现的适用场景如何？各有什么优缺点。</p><p>请你按顺序做：</p><ol><li><p>用最少概念解释 轮询与回调机制（不超过 120 字）</p></li><li><p>澄清我的解释</p></li><li><p>回答我的问题</p></li><li><p>给 3 个类比，但指出类比哪里会误导</p></li><li><p>问我 5 个递进问题来检查理解（先别给答案）</p></li><li><p>我回答后，你再指出我的漏洞并纠正</p></li></ol><p><strong>轮询与回调机制的本质</strong></p><p>轮询是主动反复询问状态；回调是被动等待对方通知。两者都用于解耦任务发起与结果获取，但通信方向相反。</p><p><strong>对你表述的澄清</strong></p><p>你说“轮询和回调都可以避免长连接的建立”，这不准确。首先，轮询本身通常基于短连接（每次查询新建连接），但频繁轮询反而可能造成大量短连接开销；而回调往往需要预先建立一个可被调用的端点（如 HTTP webhook 或消息队列消费者），这个端点可能维持监听状态，未必“避免连接”。更关键的是：两者目的不是“避免长连接”，而是实现<strong>异步解耦</strong>——让请求方不必阻塞等待结果。</p><p>其次，“回调暴露一个端口”这个说法容易误导。现代系统中，回调未必是网络端口，可能是函数指针、事件监听器、消息队列订阅者，甚至云服务中的 webhook URL。重点在于“注册一个处理逻辑供事后调用”，而非物理端口。</p><p><strong>适用场景与优缺点分析</strong></p><ul><li><p><strong>轮询适用场景</strong>：</p><ul><li>对方系统不支持回调（如老旧 API）；</li><li>网络环境限制（如内网无法被外网回调）；</li><li>任务完成时间较短且可预测；</li><li>需要精确控制查询节奏或重试策略。</li></ul><p><strong>优点</strong>：实现简单，客户端完全掌控流程，无需开放入站接口。<br><strong>缺点</strong>：延迟高（取决于轮询间隔）、资源浪费（空查询多）、扩展性差（用户越多，无效请求越多）。</p></li><li><p><strong>回调适用场景</strong>：</p><ul><li>任务耗时长且不确定（如支付处理、视频转码）；</li><li>高并发系统需低延迟通知；</li><li>双方协议支持事件驱动（如 Webhook、AMQP、Kafka）；</li><li>调用方能提供稳定可访问的回调入口。</li></ul><p><strong>优点</strong>：实时性强、资源高效（仅在事件发生时通信）、适合高吞吐。<br><strong>缺点</strong>：实现复杂（需处理幂等、重试、认证）、依赖网络可达性、调试困难（异步链路难追踪）。</p></li></ul><p><strong>三个类比及其误导点</strong></p><ol><li><p><strong>类比</strong>：轮询像你每隔5分钟打电话问快递到了没；回调像快递员到门口直接按门铃。<br><strong>误导</strong>：现实中“按门铃”需要你在家（即服务必须在线），但很多人误以为回调是“自动完成”，忽略了回调端必须持续可用。</p></li><li><p><strong>类比</strong>：轮询是学生不断举手问老师“可以交卷了吗？”；回调是老师批完卷子主动喊学生名字。<br><strong>误导</strong>：这个类比隐含“老师一定记得喊你”，但实际回调可能失败、丢失，需重试机制——而类比中没体现可靠性问题。</p></li><li><p><strong>类比</strong>：轮询像定时刷新邮箱看有没有新邮件；回调像邮件一到就弹出通知。<br><strong>误导</strong>：弹通知的前提是邮件客户端一直运行并连接服务器，这其实是一种“长连接”或后台服务，与“避免连接”的说法矛盾。</p></li></ol><p><strong>五个递进问题（请逐一回答）</strong></p><ol><li><p>如果一个任务平均10秒完成，但有时长达5分钟，用轮询的话，轮询间隔设为多少？为什么这个选择很尴尬？</p></li><li><p>回调机制中，如果对方第一次调用你的回调接口失败了（比如你服务宕机），通常怎么保证最终能通知到你？</p></li><li><p>在浏览器前端调用一个后端异步任务，为什么通常只能用轮询而很难用回调？</p></li><li><p>假设你设计一个支付系统，用户付款后第三方支付平台要通知你结果。你会选轮询还是回调？为什么？</p></li><li><p>能否设计一种混合模式，既用轮询又用回调？在什么情况下这种混合是有价值的？</p></li><li><p>如果一个任务平均10秒完成，但有时长达5分钟，用轮询的话，轮询间隔设为多少？为什么这个选择很尴尬？</p><ol><li><p>10秒</p></li><li><p>因为，存在一定的情况，需要轮询30次才能得到结果</p></li><li><p>无法避免这样的情况</p></li><li><p>但是，如果加长轮询间隔，对于那些很快得到结果的任务，又平白多了等待时间。</p></li></ol></li><li><p>回调机制中，如果对方第一次调用你的回调接口失败了（比如你服务宕机），通常怎么保证最终能通知到你？</p><ol><li><p>设置定时任务</p></li><li><p>直到回调成功。</p></li></ol></li><li><p>在浏览器前端调用一个后端异步任务，为什么通常只能用轮询而很难用回调？</p><ol><li><p>前端不方便暴露这种端口</p></li><li><p>前端本身就是不稳定的</p></li></ol></li><li><p>假设你设计一个支付系统，用户付款后第三方支付平台要通知你结果。你会选轮询还是回调？为什么？</p><ol><li><p>轮询</p></li><li><p>这样我可以更加掌控这个过程</p></li><li><p>而且支付过程本身也耗时不长</p></li></ol></li><li><p>能否设计一种混合模式，既用轮询又用回调？在什么情况下这种混合是有价值的？</p><ol><li>可以</li><li>对于最终一致性有着很强的要求，使用轮询兜底</li><li>但是，对于及时性也要要求，希望立刻得到结果，使用回调。</li></ol></li></ol><p>另外，我正在开发一个项目，后端调用DeepSeek-OCR服务，使用异步，基于轮询，但是</p><p>OCR 服务宕机了，pending 会变什么？</p><p>OCR 返回了 finished，但写 ES 失败了呢？</p><p>后端重启，Redis 里的任务怎么办？</p><p>我是否应该放弃轮询，而是让OCR主动通知后端。</p><p><strong>对你的回答的漏洞分析与纠正</strong></p><hr><h3 id="问题1-轮询间隔的尴尬" tabindex="-1"><a class="header-anchor" href="#问题1-轮询间隔的尴尬"><span><strong>问题1：轮询间隔的尴尬</strong></span></a></h3><p>你的回答方向基本正确，但表述粗糙且未触及核心矛盾。</p><ul><li>你说“设为10秒”，这其实是最差选择之一。因为： <ul><li>对于10秒完成的任务，你平均要等5秒（理想情况），但</li><li>对于5分钟（300秒）完成的任务，你要轮询30次，产生29次无效请求。</li></ul></li><li>更关键的是：<strong>无论你选多短或多长的间隔，都无法同时优化延迟和资源消耗</strong>。这就是“尴尬”所在——它暴露了轮询在<strong>不确定性高、耗时跨度大</strong>场景下的根本缺陷。</li></ul><p><strong>纠正</strong>：这种场景恰恰是回调的典型适用区。若必须用轮询，应采用<strong>指数退避轮询</strong>（如首次1秒，然后2、4、8…秒），而非固定间隔。</p><hr><h3 id="问题2-回调失败后的保障机制" tabindex="-1"><a class="header-anchor" href="#问题2-回调失败后的保障机制"><span><strong>问题2：回调失败后的保障机制</strong></span></a></h3><p>你答“设置定时任务直到成功”，这是严重误解。</p><ul><li>回调的可靠性<strong>不应由你主动轮询来兜底</strong>，而应由<strong>对方系统负责重试</strong>。</li><li>正确做法是：支付平台（或OCR服务）在调用你的回调失败后，按策略（如指数退避）重试多次（例如5次），并记录失败日志供人工介入。</li><li>如果你反过来去“轮询对方是否通知成功”，那就完全违背了回调的初衷，变成了“轮询+伪回调”的混乱架构。</li></ul><p><strong>纠正</strong>：回调的可靠性依赖于<strong>通知方的重试机制 + 接收方的幂等处理</strong>，而不是接收方去反向轮询。</p><hr><h3 id="问题3-前端为何难用回调" tabindex="-1"><a class="header-anchor" href="#问题3-前端为何难用回调"><span><strong>问题3：前端为何难用回调</strong></span></a></h3><p>你说“前端不方便暴露端口”是对的，但理由不完整。</p><ul><li>浏览器中的 JavaScript 运行在客户端，<strong>无法被公网服务直接回调</strong>（没有固定IP、NAT、防火墙、安全策略限制）。</li><li>即使使用 WebSocket 或 SSE（Server-Sent Events），那也是<strong>服务端主动推送</strong>，本质上仍是服务端维持连接，而非传统“回调”。</li><li>所以，前端异步任务几乎只能靠轮询（或长轮询/流式响应），这是由网络拓扑决定的，不是“不稳定”的问题。</li></ul><p><strong>纠正</strong>：“前端不稳定”是结果，不是原因；根本原因是<strong>前端不可被寻址（non-addressable）</strong>。</p><hr><h3 id="问题4-支付系统该用轮询还是回调" tabindex="-1"><a class="header-anchor" href="#问题4-支付系统该用轮询还是回调"><span><strong>问题4：支付系统该用轮询还是回调？</strong></span></a></h3><p>你选轮询，理由错误。</p><ul><li>支付平台（如支付宝、Stripe）<strong>标准做法是回调（Webhook）</strong>，辅以<strong>商户主动查询接口作为兜底</strong>。</li><li>你说“我可以更掌控过程”，这是幻觉。轮询无法保证实时到账通知，用户可能已付款但你5秒后才知道，影响体验。</li><li>而且，“支付耗时不长”不是理由——哪怕1秒完成，回调也能立刻通知；轮询至少有1秒延迟。</li></ul><p><strong>纠正</strong>：支付系统应<strong>优先回调，轮询仅作灾备</strong>。你所谓的“掌控”，其实是放弃了实时性和效率。</p><hr><h3 id="问题5-混合模式" tabindex="-1"><a class="header-anchor" href="#问题5-混合模式"><span><strong>问题5：混合模式</strong></span></a></h3><p>这部分你答得最好，接近正确。</p><ul><li>混合模式确实存在：<strong>主路径用回调，超时未收到则启动轮询兜底</strong>。</li><li>适用于对<strong>最终一致性要求高 + 网络不可靠</strong>的场景（如金融、IoT）。</li><li>但要注意：必须设计好<strong>去重机制</strong>，避免回调和轮询结果重复处理。</li></ul><p><strong>肯定</strong>：这点你理解到位。</p><hr><h2 id="针对你项目的具体问题" tabindex="-1"><a class="header-anchor" href="#针对你项目的具体问题"><span><strong>针对你项目的具体问题</strong></span></a></h2><blockquote><p>我正在开发一个项目，后端调用DeepSeek-OCR服务，使用异步，基于轮询</p></blockquote><h3 id="q1-ocr-服务宕机了-pending-会变什么" tabindex="-1"><a class="header-anchor" href="#q1-ocr-服务宕机了-pending-会变什么"><span><strong>Q1: OCR 服务宕机了，pending 会变什么？</strong></span></a></h3><ul><li>如果 OCR 服务彻底宕机且无状态保存，你的任务可能<strong>永远卡在 pending</strong>。</li><li>如果 OCR 服务有任务队列（如 Redis、Kafka），任务可能排队等待，恢复后继续处理。</li><li><strong>但你的轮询逻辑若无超时/失败重试机制，就会无限等待</strong>。</li></ul><h3 id="q2-ocr-返回-finished-但写-es-失败了呢" tabindex="-1"><a class="header-anchor" href="#q2-ocr-返回-finished-但写-es-失败了呢"><span><strong>Q2: OCR 返回 finished，但写 ES 失败了呢？</strong></span></a></h3><ul><li>这属于<strong>你的后处理失败</strong>，与 OCR 无关。</li><li>正确做法：将“写 ES”也纳入事务或重试流程。可记录任务状态为 <code>finished_but_index_failed</code>，由后台任务补偿。</li><li>若不做处理，数据就丢失了——这是<strong>轮询架构中常见的状态管理漏洞</strong>。</li></ul><h3 id="q3-后端重启-redis-里的任务怎么办" tabindex="-1"><a class="header-anchor" href="#q3-后端重启-redis-里的任务怎么办"><span><strong>Q3: 后端重启，Redis 里的任务怎么办？</strong></span></a></h3><ul><li>如果任务状态存在 Redis，且你的服务能从 Redis 恢复上下文，那可以继续轮询。</li><li>但如果轮询是由 HTTP 请求触发的一次性逻辑（无持久化任务ID追踪），重启后<strong>任务就“孤儿化”了</strong>。</li><li><strong>建议</strong>：所有异步任务必须有<strong>持久化任务记录表</strong>（数据库或 Redis Hash），包含状态、创建时间、最后轮询时间、重试次数等。</li></ul><h3 id="q4-是否该放弃轮询-改用-ocr-主动通知" tabindex="-1"><a class="header-anchor" href="#q4-是否该放弃轮询-改用-ocr-主动通知"><span><strong>Q4: 是否该放弃轮询，改用 OCR 主动通知？</strong></span></a></h3><p><strong>强烈建议切换到回调（如果 DeepSeek-OCR 支持 Webhook）</strong>。理由：</p><ol><li><strong>效率</strong>：OCR 完成即通知，无需你每秒查一次；</li><li><strong>可靠性</strong>：配合重试 + 幂等，比轮询更可控；</li><li><strong>资源节省</strong>：避免大量空轮询压垮你的服务或 OCR 的 API 限流；</li><li><strong>可维护性</strong>：状态流转更清晰（submitted → processing → done → indexed）。</li></ol><p>如果 DeepSeek-OCR <strong>不支持回调</strong>，那你只能优化轮询：</p><ul><li>使用<strong>动态退避策略</strong>；</li><li>设置<strong>最大轮询次数/超时时间</strong>；</li><li>任务状态持久化，支持服务重启后恢复；</li><li>增加<strong>告警机制</strong>（pending 超过5分钟触发告警）。</li></ul><hr><p><strong>下一步建议</strong></p><p>你现在的问题不是“轮询 vs 回调”的理论选择，而是<strong>缺乏异步任务的状态机设计和容错机制</strong>。建议：</p><ol><li>画出任务全生命周期状态图；</li><li>为每个状态定义超时、失败、重试策略；</li><li>无论用轮询还是回调，都要有<strong>兜底查询机制</strong>（即混合模式）；</li><li>所有外部调用（OCR、ES）都要考虑<strong>失败补偿</strong>。</li></ol><p>现在，请重新思考：如果你的 OCR 服务<strong>明天就支持 Webhook</strong>，你会如何改造现有架构？</p><ol><li>画出任务全生命周期状态图；</li><li>为每个状态定义超时、失败、重试策略；</li><li>无论用轮询还是回调，都要有<strong>兜底查询机制</strong>（即混合模式）；</li><li>所有外部调用（OCR、ES）都要考虑<strong>失败补偿</strong>。</li></ol></div><!----><!----><!----><footer class="vp-doc-footer" data-v-155f52e8 data-v-07724fb9><!--[--><!--]--><!----><div class="contributors" aria-label="Contributors" data-v-07724fb9><span class="contributors-label" data-v-07724fb9>贡献者: </span><span class="contributors-info" data-v-07724fb9><!--[--><!--[--><span class="contributor" data-v-07724fb9>si-xiao-min</span><!----><!--]--><!--]--></span></div><nav class="prev-next" data-v-07724fb9><div class="pager" data-v-07724fb9><a class="vp-link link pager-link prev" href="/blog/mnnxdiz1/" data-v-07724fb9><!--[--><span class="desc" data-v-07724fb9>上一页</span><span class="title" data-v-07724fb9><!----><span data-v-07724fb9>自定义组件</span></span><!--]--></a></div><div class="pager" data-v-07724fb9><!----></div></nav></footer></div><!--]--></main><!----><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!--]--><button type="button" class="vp-back-to-top" aria-label="back to top" data-v-3a454f83 style="display:none;" data-v-934dfee6><span class="percent" data-allow-mismatch data-v-934dfee6>0%</span><span class="show icon vpi-back-to-top" data-v-934dfee6></span><svg aria-hidden="true" data-v-934dfee6><circle cx="50%" cy="50%" data-allow-mismatch style="stroke-dasharray:calc(0% - 12.566370614359172px) calc(314.1592653589793% - 12.566370614359172px);" data-v-934dfee6></circle></svg></button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="sign down" class="vp-sign-down" aria-hidden="true" data-v-3a454f83 style="display:none;" data-v-7cde8a0a><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" data-v-7cde8a0a><path d="m19 11l-7 6l-7-6" data-v-7cde8a0a></path><path d="m19 5l-7 6l-7-6" opacity="0.6" data-v-7cde8a0a></path></g></svg><footer class="vp-footer" vp-footer data-v-3a454f83 data-v-d33ed502><!--[--><div class="container" data-v-d33ed502><div class="message" data-v-d33ed502>Powered by <a target="_blank" href="https://v2.vuepress.vuejs.org/">VuePress</a> & <a target="_blank" href="https://theme-plume.vuejs.press">vuepress-theme-plume</a></div><!----></div><!--]--></footer><!--[--><!--]--><!--]--></div><!----><!--]--><!--[--><!--]--><!--]--></div><script type="module" src="/assets/app-B9c7vheQ.js" defer></script></body></html>